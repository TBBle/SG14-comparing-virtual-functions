
release/Main:     file format elf64-x86-64


Disassembly of section .init:

0000000000402500 <_init>:
  402500:	48 83 ec 08          	sub    $0x8,%rsp
  402504:	48 8b 05 ed 4a 20 00 	mov    0x204aed(%rip),%rax        # 606ff8 <_DYNAMIC+0x1f0>
  40250b:	48 85 c0             	test   %rax,%rax
  40250e:	74 05                	je     402515 <_init+0x15>
  402510:	e8 2b 00 00 00       	callq  402540 <__gmon_start__@plt>
  402515:	48 83 c4 08          	add    $0x8,%rsp
  402519:	c3                   	retq   

Disassembly of section .plt:

0000000000402520 <_ZSt16__throw_bad_castv@plt-0x10>:
  402520:	ff 35 e2 4a 20 00    	pushq  0x204ae2(%rip)        # 607008 <_GLOBAL_OFFSET_TABLE_+0x8>
  402526:	ff 25 e4 4a 20 00    	jmpq   *0x204ae4(%rip)        # 607010 <_GLOBAL_OFFSET_TABLE_+0x10>
  40252c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000402530 <_ZSt16__throw_bad_castv@plt>:
  402530:	ff 25 e2 4a 20 00    	jmpq   *0x204ae2(%rip)        # 607018 <_GLOBAL_OFFSET_TABLE_+0x18>
  402536:	68 00 00 00 00       	pushq  $0x0
  40253b:	e9 e0 ff ff ff       	jmpq   402520 <_init+0x20>

0000000000402540 <__gmon_start__@plt>:
  402540:	ff 25 da 4a 20 00    	jmpq   *0x204ada(%rip)        # 607020 <_GLOBAL_OFFSET_TABLE_+0x20>
  402546:	68 01 00 00 00       	pushq  $0x1
  40254b:	e9 d0 ff ff ff       	jmpq   402520 <_init+0x20>

0000000000402550 <_ZdlPv@plt>:
  402550:	ff 25 d2 4a 20 00    	jmpq   *0x204ad2(%rip)        # 607028 <_GLOBAL_OFFSET_TABLE_+0x28>
  402556:	68 02 00 00 00       	pushq  $0x2
  40255b:	e9 c0 ff ff ff       	jmpq   402520 <_init+0x20>

0000000000402560 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>:
  402560:	ff 25 ca 4a 20 00    	jmpq   *0x204aca(%rip)        # 607030 <_GLOBAL_OFFSET_TABLE_+0x30>
  402566:	68 03 00 00 00       	pushq  $0x3
  40256b:	e9 b0 ff ff ff       	jmpq   402520 <_init+0x20>

0000000000402570 <_ZNSt8ios_base4InitC1Ev@plt>:
  402570:	ff 25 c2 4a 20 00    	jmpq   *0x204ac2(%rip)        # 607038 <_GLOBAL_OFFSET_TABLE_+0x38>
  402576:	68 04 00 00 00       	pushq  $0x4
  40257b:	e9 a0 ff ff ff       	jmpq   402520 <_init+0x20>

0000000000402580 <__libc_start_main@plt>:
  402580:	ff 25 ba 4a 20 00    	jmpq   *0x204aba(%rip)        # 607040 <_GLOBAL_OFFSET_TABLE_+0x40>
  402586:	68 05 00 00 00       	pushq  $0x5
  40258b:	e9 90 ff ff ff       	jmpq   402520 <_init+0x20>

0000000000402590 <_ZNSt6chrono3_V212system_clock3nowEv@plt>:
  402590:	ff 25 b2 4a 20 00    	jmpq   *0x204ab2(%rip)        # 607048 <_GLOBAL_OFFSET_TABLE_+0x48>
  402596:	68 06 00 00 00       	pushq  $0x6
  40259b:	e9 80 ff ff ff       	jmpq   402520 <_init+0x20>

00000000004025a0 <__cxa_atexit@plt>:
  4025a0:	ff 25 aa 4a 20 00    	jmpq   *0x204aaa(%rip)        # 607050 <_GLOBAL_OFFSET_TABLE_+0x50>
  4025a6:	68 07 00 00 00       	pushq  $0x7
  4025ab:	e9 70 ff ff ff       	jmpq   402520 <_init+0x20>

00000000004025b0 <_ZNSt8ios_base4InitD1Ev@plt>:
  4025b0:	ff 25 a2 4a 20 00    	jmpq   *0x204aa2(%rip)        # 607058 <_GLOBAL_OFFSET_TABLE_+0x58>
  4025b6:	68 08 00 00 00       	pushq  $0x8
  4025bb:	e9 60 ff ff ff       	jmpq   402520 <_init+0x20>

00000000004025c0 <__cxa_pure_virtual@plt>:
  4025c0:	ff 25 9a 4a 20 00    	jmpq   *0x204a9a(%rip)        # 607060 <_GLOBAL_OFFSET_TABLE_+0x60>
  4025c6:	68 09 00 00 00       	pushq  $0x9
  4025cb:	e9 50 ff ff ff       	jmpq   402520 <_init+0x20>

00000000004025d0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>:
  4025d0:	ff 25 92 4a 20 00    	jmpq   *0x204a92(%rip)        # 607068 <_GLOBAL_OFFSET_TABLE_+0x68>
  4025d6:	68 0a 00 00 00       	pushq  $0xa
  4025db:	e9 40 ff ff ff       	jmpq   402520 <_init+0x20>

00000000004025e0 <memmove@plt>:
  4025e0:	ff 25 8a 4a 20 00    	jmpq   *0x204a8a(%rip)        # 607070 <_GLOBAL_OFFSET_TABLE_+0x70>
  4025e6:	68 0b 00 00 00       	pushq  $0xb
  4025eb:	e9 30 ff ff ff       	jmpq   402520 <_init+0x20>

00000000004025f0 <_ZNSo5flushEv@plt>:
  4025f0:	ff 25 82 4a 20 00    	jmpq   *0x204a82(%rip)        # 607078 <_GLOBAL_OFFSET_TABLE_+0x78>
  4025f6:	68 0c 00 00 00       	pushq  $0xc
  4025fb:	e9 20 ff ff ff       	jmpq   402520 <_init+0x20>

0000000000402600 <_ZNSo9_M_insertIdEERSoT_@plt>:
  402600:	ff 25 7a 4a 20 00    	jmpq   *0x204a7a(%rip)        # 607080 <_GLOBAL_OFFSET_TABLE_+0x80>
  402606:	68 0d 00 00 00       	pushq  $0xd
  40260b:	e9 10 ff ff ff       	jmpq   402520 <_init+0x20>

0000000000402610 <__gxx_personality_v0@plt>:
  402610:	ff 25 72 4a 20 00    	jmpq   *0x204a72(%rip)        # 607088 <_GLOBAL_OFFSET_TABLE_+0x88>
  402616:	68 0e 00 00 00       	pushq  $0xe
  40261b:	e9 00 ff ff ff       	jmpq   402520 <_init+0x20>

0000000000402620 <_Znwm@plt>:
  402620:	ff 25 6a 4a 20 00    	jmpq   *0x204a6a(%rip)        # 607090 <_GLOBAL_OFFSET_TABLE_+0x90>
  402626:	68 0f 00 00 00       	pushq  $0xf
  40262b:	e9 f0 fe ff ff       	jmpq   402520 <_init+0x20>

0000000000402630 <_Unwind_Resume@plt>:
  402630:	ff 25 62 4a 20 00    	jmpq   *0x204a62(%rip)        # 607098 <_GLOBAL_OFFSET_TABLE_+0x98>
  402636:	68 10 00 00 00       	pushq  $0x10
  40263b:	e9 e0 fe ff ff       	jmpq   402520 <_init+0x20>

0000000000402640 <_ZNSo3putEc@plt>:
  402640:	ff 25 5a 4a 20 00    	jmpq   *0x204a5a(%rip)        # 6070a0 <_GLOBAL_OFFSET_TABLE_+0xa0>
  402646:	68 11 00 00 00       	pushq  $0x11
  40264b:	e9 d0 fe ff ff       	jmpq   402520 <_init+0x20>

Disassembly of section .text:

0000000000402650 <_GLOBAL__sub_I__Z4lerpfff>:


entity_lerp_slow* create_entity_lerp_slow(float p1, float p2)
{
	return new entity_lerp_slow_impl(p1, p2);
}
  402650:	48 83 ec 08          	sub    $0x8,%rsp
  extern wostream wclog;	/// Linked to standard error (buffered)
#endif
  //@}

  // For construction of filebuffers for cout, cin, cerr, clog et. al.
  static ios_base::Init __ioinit;
  402654:	bf a8 72 60 00       	mov    $0x6072a8,%edi
  402659:	e8 12 ff ff ff       	callq  402570 <_ZNSt8ios_base4InitC1Ev@plt>
  40265e:	ba b0 70 60 00       	mov    $0x6070b0,%edx
  402663:	be a8 72 60 00       	mov    $0x6072a8,%esi
  402668:	bf b0 25 40 00       	mov    $0x4025b0,%edi
  40266d:	e8 2e ff ff ff       	callq  4025a0 <__cxa_atexit@plt>
	pointer _M_start;
	pointer _M_finish;
	pointer _M_end_of_storage;

	_Vector_impl()
	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
  402672:	48 c7 05 13 4c 20 00 	movq   $0x0,0x204c13(%rip)        # 607290 <_ZL11s_positions>
  402679:	00 00 00 00 
  40267d:	48 c7 05 10 4c 20 00 	movq   $0x0,0x204c10(%rip)        # 607298 <_ZL11s_positions+0x8>
  402684:	00 00 00 00 
};

const long long entity_lerp_fast::type = 2LL;


static std::vector<Pos> s_positions;
  402688:	ba b0 70 60 00       	mov    $0x6070b0,%edx
  40268d:	48 c7 05 08 4c 20 00 	movq   $0x0,0x204c08(%rip)        # 6072a0 <_ZL11s_positions+0x10>
  402694:	00 00 00 00 
  402698:	be 90 72 60 00       	mov    $0x607290,%esi
  40269d:	bf 60 30 40 00       	mov    $0x403060,%edi


entity_lerp_slow* create_entity_lerp_slow(float p1, float p2)
{
	return new entity_lerp_slow_impl(p1, p2);
}
  4026a2:	48 83 c4 08          	add    $0x8,%rsp
};

const long long entity_lerp_fast::type = 2LL;


static std::vector<Pos> s_positions;
  4026a6:	e9 f5 fe ff ff       	jmpq   4025a0 <__cxa_atexit@plt>
  4026ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000004026b0 <_GLOBAL__sub_I__Z7hermitefffff>:
};

entity_hermite* create_entity_hermite(float p1, float p2, float n1, float n2)
{
	return new entity_hermite_impl(p1, p2, n1, n2);
  4026b0:	48 83 ec 08          	sub    $0x8,%rsp
  4026b4:	bf a9 72 60 00       	mov    $0x6072a9,%edi
  4026b9:	e8 b2 fe ff ff       	callq  402570 <_ZNSt8ios_base4InitC1Ev@plt>
  4026be:	ba b0 70 60 00       	mov    $0x6070b0,%edx
  4026c3:	be a9 72 60 00       	mov    $0x6072a9,%esi
  4026c8:	bf b0 25 40 00       	mov    $0x4025b0,%edi
  4026cd:	48 83 c4 08          	add    $0x8,%rsp
  4026d1:	e9 ca fe ff ff       	jmpq   4025a0 <__cxa_atexit@plt>
  4026d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4026dd:	00 00 00 

00000000004026e0 <main>:
	}
}
#endif

int main()
{
  4026e0:	41 55                	push   %r13
  4026e2:	41 54                	push   %r12
  4026e4:	55                   	push   %rbp
  4026e5:	bd 40 73 60 00       	mov    $0x607340,%ebp
  4026ea:	53                   	push   %rbx
  4026eb:	48 83 ec 18          	sub    $0x18,%rsp
	SlowUpdateExample();
  4026ef:	e8 5c 0c 00 00       	callq  403350 <_Z17SlowUpdateExamplev>
	SlowComplicatedUpdateExample();
  4026f4:	e8 67 1e 00 00       	callq  404560 <_Z28SlowComplicatedUpdateExamplev>
	FastUpdateExampleTimers();
  4026f9:	e8 42 18 00 00       	callq  403f40 <_Z23FastUpdateExampleTimersv>
  4026fe:	66 90                	xchg   %ax,%ax
#ifdef __GNUC__
	MethodPointerUpdateExampleTimers();
  402700:	e8 3b 12 00 00       	callq  403940 <_Z32MethodPointerUpdateExampleTimersv>
  402705:	eb 2d                	jmp    402734 <main+0x54>
  402707:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40270e:	00 00 
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
	  return _M_widen[static_cast<unsigned char>(__c)];
  402710:	0f b6 43 43          	movzbl 0x43(%rbx),%eax
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  402714:	0f be f0             	movsbl %al,%esi
  402717:	4c 89 e7             	mov    %r12,%rdi
  40271a:	48 83 c5 04          	add    $0x4,%rbp
  40271e:	e8 1d ff ff ff       	callq  402640 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  402723:	48 89 c7             	mov    %rax,%rdi
  402726:	e8 c5 fe ff ff       	callq  4025f0 <_ZNSo5flushEv@plt>
#endif

	for (auto a : dummyOut)
  40272b:	48 81 fd d0 74 60 00 	cmp    $0x6074d0,%rbp
  402732:	74 74                	je     4027a8 <main+0xc8>
  402734:	f3 0f 10 4d 00       	movss  0x0(%rbp),%xmm1
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  402739:	ba 09 00 00 00       	mov    $0x9,%edx
  40273e:	be 24 58 40 00       	mov    $0x405824,%esi
  402743:	bf 20 71 60 00       	mov    $0x607120,%edi
  402748:	f3 0f 11 4c 24 08    	movss  %xmm1,0x8(%rsp)
  40274e:	e8 7d fe ff ff       	callq  4025d0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
      __ostream_type&
      operator<<(float __f)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<double>(__f));
  402753:	f3 0f 10 44 24 08    	movss  0x8(%rsp),%xmm0
  402759:	bf 20 71 60 00       	mov    $0x607120,%edi
  40275e:	0f 5a c0             	cvtps2pd %xmm0,%xmm0
  402761:	e8 9a fe ff ff       	callq  402600 <_ZNSo9_M_insertIdEERSoT_@plt>
  402766:	49 89 c4             	mov    %rax,%r12
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  402769:	48 8b 00             	mov    (%rax),%rax
  40276c:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  402770:	49 8b 9c 04 f0 00 00 	mov    0xf0(%r12,%rax,1),%rbx
  402777:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  402778:	48 85 db             	test   %rbx,%rbx
  40277b:	0f 84 d0 02 00 00    	je     402a51 <main+0x371>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  402781:	80 7b 38 00          	cmpb   $0x0,0x38(%rbx)
  402785:	75 89                	jne    402710 <main+0x30>
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  402787:	48 89 df             	mov    %rbx,%rdi
  40278a:	e8 d1 fd ff ff       	callq  402560 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  40278f:	48 8b 03             	mov    (%rbx),%rax
  402792:	be 0a 00 00 00       	mov    $0xa,%esi
  402797:	48 89 df             	mov    %rbx,%rdi
  40279a:	ff 50 30             	callq  *0x30(%rax)
  40279d:	e9 72 ff ff ff       	jmpq   402714 <main+0x34>
  4027a2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      typedef typename __traits_type::pointer   	pointer;

      _GLIBCXX_CONSTEXPR __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
  4027a8:	4c 8b 2d 79 4b 20 00 	mov    0x204b79(%rip),%r13        # 607328 <gSlowSimpleUpdateExampleTimers+0x8>
  4027af:	48 8b 2d 6a 4b 20 00 	mov    0x204b6a(%rip),%rbp        # 607320 <gSlowSimpleUpdateExampleTimers>
	{
		cout << "dummyOut " << a << endl;
	}

	for (auto & t : gSlowSimpleUpdateExampleTimers)
  4027b6:	4c 39 ed             	cmp    %r13,%rbp
  4027b9:	75 25                	jne    4027e0 <main+0x100>
  4027bb:	e9 90 00 00 00       	jmpq   402850 <main+0x170>
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
	  return _M_widen[static_cast<unsigned char>(__c)];
  4027c0:	0f b6 43 43          	movzbl 0x43(%rbx),%eax
  4027c4:	0f be f0             	movsbl %al,%esi
  4027c7:	4c 89 e7             	mov    %r12,%rdi
  4027ca:	48 83 c5 08          	add    $0x8,%rbp
  4027ce:	e8 6d fe ff ff       	callq  402640 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  4027d3:	48 89 c7             	mov    %rax,%rdi
  4027d6:	e8 15 fe ff ff       	callq  4025f0 <_ZNSo5flushEv@plt>
  4027db:	49 39 ed             	cmp    %rbp,%r13
  4027de:	74 70                	je     402850 <main+0x170>
	duration& operator=(const duration&) = default;

	// 20.11.5.2 observer
	constexpr rep
	count() const
	{ return __r; }
  4027e0:	f2 0f 10 45 00       	movsd  0x0(%rbp),%xmm0
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  4027e5:	ba 16 00 00 00       	mov    $0x16,%edx
  4027ea:	be 2e 58 40 00       	mov    $0x40582e,%esi
  4027ef:	bf 20 71 60 00       	mov    $0x607120,%edi
  4027f4:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
  4027fa:	e8 d1 fd ff ff       	callq  4025d0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      */
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }
  4027ff:	f2 0f 10 44 24 08    	movsd  0x8(%rsp),%xmm0
  402805:	bf 20 71 60 00       	mov    $0x607120,%edi
  40280a:	e8 f1 fd ff ff       	callq  402600 <_ZNSo9_M_insertIdEERSoT_@plt>
  40280f:	49 89 c4             	mov    %rax,%r12
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  402812:	48 8b 00             	mov    (%rax),%rax
  402815:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  402819:	49 8b 9c 04 f0 00 00 	mov    0xf0(%r12,%rax,1),%rbx
  402820:	00 
  402821:	48 85 db             	test   %rbx,%rbx
  402824:	0f 84 27 02 00 00    	je     402a51 <main+0x371>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  40282a:	80 7b 38 00          	cmpb   $0x0,0x38(%rbx)
  40282e:	75 90                	jne    4027c0 <main+0xe0>
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  402830:	48 89 df             	mov    %rbx,%rdi
  402833:	e8 28 fd ff ff       	callq  402560 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  402838:	48 8b 03             	mov    (%rbx),%rax
  40283b:	be 0a 00 00 00       	mov    $0xa,%esi
  402840:	48 89 df             	mov    %rbx,%rdi
  402843:	ff 50 30             	callq  *0x30(%rax)
  402846:	e9 79 ff ff ff       	jmpq   4027c4 <main+0xe4>
  40284b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  402850:	4c 8b 2d b1 4a 20 00 	mov    0x204ab1(%rip),%r13        # 607308 <gSlowComplicatedUpdateExampleTimers+0x8>
  402857:	48 8b 2d a2 4a 20 00 	mov    0x204aa2(%rip),%rbp        # 607300 <gSlowComplicatedUpdateExampleTimers>
	{
		cout << "gSlowUpdateExample ms " << t.count() << endl;
	}
	for (auto & t : gSlowComplicatedUpdateExampleTimers)
  40285e:	4c 39 ed             	cmp    %r13,%rbp
  402861:	75 2d                	jne    402890 <main+0x1b0>
  402863:	e9 93 00 00 00       	jmpq   4028fb <main+0x21b>
  402868:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40286f:	00 
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
	  return _M_widen[static_cast<unsigned char>(__c)];
  402870:	0f b6 43 43          	movzbl 0x43(%rbx),%eax
  402874:	0f be f0             	movsbl %al,%esi
  402877:	4c 89 e7             	mov    %r12,%rdi
  40287a:	48 83 c5 08          	add    $0x8,%rbp
  40287e:	e8 bd fd ff ff       	callq  402640 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  402883:	48 89 c7             	mov    %rax,%rdi
  402886:	e8 65 fd ff ff       	callq  4025f0 <_ZNSo5flushEv@plt>
  40288b:	49 39 ed             	cmp    %rbp,%r13
  40288e:	74 6b                	je     4028fb <main+0x21b>
  402890:	f2 0f 10 45 00       	movsd  0x0(%rbp),%xmm0
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  402895:	ba 27 00 00 00       	mov    $0x27,%edx
  40289a:	be 68 58 40 00       	mov    $0x405868,%esi
  40289f:	bf 20 71 60 00       	mov    $0x607120,%edi
  4028a4:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
  4028aa:	e8 21 fd ff ff       	callq  4025d0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      */
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }
  4028af:	f2 0f 10 44 24 08    	movsd  0x8(%rsp),%xmm0
  4028b5:	bf 20 71 60 00       	mov    $0x607120,%edi
  4028ba:	e8 41 fd ff ff       	callq  402600 <_ZNSo9_M_insertIdEERSoT_@plt>
  4028bf:	49 89 c4             	mov    %rax,%r12
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  4028c2:	48 8b 00             	mov    (%rax),%rax
  4028c5:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  4028c9:	49 8b 9c 04 f0 00 00 	mov    0xf0(%r12,%rax,1),%rbx
  4028d0:	00 
  4028d1:	48 85 db             	test   %rbx,%rbx
  4028d4:	0f 84 77 01 00 00    	je     402a51 <main+0x371>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  4028da:	80 7b 38 00          	cmpb   $0x0,0x38(%rbx)
  4028de:	75 90                	jne    402870 <main+0x190>
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  4028e0:	48 89 df             	mov    %rbx,%rdi
  4028e3:	e8 78 fc ff ff       	callq  402560 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  4028e8:	48 8b 03             	mov    (%rbx),%rax
  4028eb:	be 0a 00 00 00       	mov    $0xa,%esi
  4028f0:	48 89 df             	mov    %rbx,%rdi
  4028f3:	ff 50 30             	callq  *0x30(%rax)
  4028f6:	e9 79 ff ff ff       	jmpq   402874 <main+0x194>
  4028fb:	4c 8b 2d e6 49 20 00 	mov    0x2049e6(%rip),%r13        # 6072e8 <gFastUpdateExampleTimers+0x8>
  402902:	48 8b 2d d7 49 20 00 	mov    0x2049d7(%rip),%rbp        # 6072e0 <gFastUpdateExampleTimers>
	{
		cout << "gSlowComplicatedUpdateExampleTimers ms " << t.count() << endl;
	}
	for (auto & t : gFastUpdateExampleTimers)
  402909:	4c 39 ed             	cmp    %r13,%rbp
  40290c:	75 2a                	jne    402938 <main+0x258>
  40290e:	e9 90 00 00 00       	jmpq   4029a3 <main+0x2c3>
  402913:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
	  return _M_widen[static_cast<unsigned char>(__c)];
  402918:	0f b6 43 43          	movzbl 0x43(%rbx),%eax
  40291c:	0f be f0             	movsbl %al,%esi
  40291f:	4c 89 e7             	mov    %r12,%rdi
  402922:	48 83 c5 08          	add    $0x8,%rbp
  402926:	e8 15 fd ff ff       	callq  402640 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  40292b:	48 89 c7             	mov    %rax,%rdi
  40292e:	e8 bd fc ff ff       	callq  4025f0 <_ZNSo5flushEv@plt>
  402933:	49 39 ed             	cmp    %rbp,%r13
  402936:	74 6b                	je     4029a3 <main+0x2c3>
  402938:	f2 0f 10 45 00       	movsd  0x0(%rbp),%xmm0
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  40293d:	ba 1c 00 00 00       	mov    $0x1c,%edx
  402942:	be 45 58 40 00       	mov    $0x405845,%esi
  402947:	bf 20 71 60 00       	mov    $0x607120,%edi
  40294c:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
  402952:	e8 79 fc ff ff       	callq  4025d0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      */
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }
  402957:	f2 0f 10 44 24 08    	movsd  0x8(%rsp),%xmm0
  40295d:	bf 20 71 60 00       	mov    $0x607120,%edi
  402962:	e8 99 fc ff ff       	callq  402600 <_ZNSo9_M_insertIdEERSoT_@plt>
  402967:	49 89 c4             	mov    %rax,%r12
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40296a:	48 8b 00             	mov    (%rax),%rax
  40296d:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  402971:	49 8b 9c 04 f0 00 00 	mov    0xf0(%r12,%rax,1),%rbx
  402978:	00 
  402979:	48 85 db             	test   %rbx,%rbx
  40297c:	0f 84 cf 00 00 00    	je     402a51 <main+0x371>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  402982:	80 7b 38 00          	cmpb   $0x0,0x38(%rbx)
  402986:	75 90                	jne    402918 <main+0x238>
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  402988:	48 89 df             	mov    %rbx,%rdi
  40298b:	e8 d0 fb ff ff       	callq  402560 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  402990:	48 8b 03             	mov    (%rbx),%rax
  402993:	be 0a 00 00 00       	mov    $0xa,%esi
  402998:	48 89 df             	mov    %rbx,%rdi
  40299b:	ff 50 30             	callq  *0x30(%rax)
  40299e:	e9 79 ff ff ff       	jmpq   40291c <main+0x23c>
  4029a3:	4c 8b 2d 1e 49 20 00 	mov    0x20491e(%rip),%r13        # 6072c8 <gMethodPointerUpdateExampleTimers+0x8>
  4029aa:	48 8b 2d 0f 49 20 00 	mov    0x20490f(%rip),%rbp        # 6072c0 <gMethodPointerUpdateExampleTimers>
	{
		cout << "gFastUpdateExampleTimers ms " << t.count() << endl;
	}
#ifdef __GNUC__
	for (auto & t : gMethodPointerUpdateExampleTimers)
  4029b1:	4c 39 ed             	cmp    %r13,%rbp
  4029b4:	75 2a                	jne    4029e0 <main+0x300>
  4029b6:	e9 89 00 00 00       	jmpq   402a44 <main+0x364>
  4029bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
	  return _M_widen[static_cast<unsigned char>(__c)];
  4029c0:	0f b6 43 43          	movzbl 0x43(%rbx),%eax
  4029c4:	0f be f0             	movsbl %al,%esi
  4029c7:	4c 89 e7             	mov    %r12,%rdi
  4029ca:	48 83 c5 08          	add    $0x8,%rbp
  4029ce:	e8 6d fc ff ff       	callq  402640 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  4029d3:	48 89 c7             	mov    %rax,%rdi
  4029d6:	e8 15 fc ff ff       	callq  4025f0 <_ZNSo5flushEv@plt>
  4029db:	49 39 ed             	cmp    %rbp,%r13
  4029de:	74 64                	je     402a44 <main+0x364>
  4029e0:	f2 0f 10 45 00       	movsd  0x0(%rbp),%xmm0
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  4029e5:	ba 25 00 00 00       	mov    $0x25,%edx
  4029ea:	be 90 58 40 00       	mov    $0x405890,%esi
  4029ef:	bf 20 71 60 00       	mov    $0x607120,%edi
  4029f4:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
  4029fa:	e8 d1 fb ff ff       	callq  4025d0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      */
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }
  4029ff:	f2 0f 10 44 24 08    	movsd  0x8(%rsp),%xmm0
  402a05:	bf 20 71 60 00       	mov    $0x607120,%edi
  402a0a:	e8 f1 fb ff ff       	callq  402600 <_ZNSo9_M_insertIdEERSoT_@plt>
  402a0f:	49 89 c4             	mov    %rax,%r12
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  402a12:	48 8b 00             	mov    (%rax),%rax
  402a15:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  402a19:	49 8b 9c 04 f0 00 00 	mov    0xf0(%r12,%rax,1),%rbx
  402a20:	00 
  402a21:	48 85 db             	test   %rbx,%rbx
  402a24:	74 2b                	je     402a51 <main+0x371>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  402a26:	80 7b 38 00          	cmpb   $0x0,0x38(%rbx)
  402a2a:	75 94                	jne    4029c0 <main+0x2e0>
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  402a2c:	48 89 df             	mov    %rbx,%rdi
  402a2f:	e8 2c fb ff ff       	callq  402560 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  402a34:	48 8b 03             	mov    (%rbx),%rax
  402a37:	be 0a 00 00 00       	mov    $0xa,%esi
  402a3c:	48 89 df             	mov    %rbx,%rdi
  402a3f:	ff 50 30             	callq  *0x30(%rax)
  402a42:	eb 80                	jmp    4029c4 <main+0x2e4>
	{
		cout << "gMethodPointerUpdateExampleTimers ms " << t.count() << endl;
	}
#endif
	return 0;
}
  402a44:	48 83 c4 18          	add    $0x18,%rsp
  402a48:	31 c0                	xor    %eax,%eax
  402a4a:	5b                   	pop    %rbx
  402a4b:	5d                   	pop    %rbp
  402a4c:	41 5c                	pop    %r12
  402a4e:	41 5d                	pop    %r13
  402a50:	c3                   	retq   
	__throw_bad_cast();
  402a51:	e8 da fa ff ff       	callq  402530 <_ZSt16__throw_bad_castv@plt>
  402a56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  402a5d:	00 00 00 

0000000000402a60 <_GLOBAL__sub_I_dummyOut>:
  402a60:	48 83 ec 08          	sub    $0x8,%rsp
  402a64:	bf d0 74 60 00       	mov    $0x6074d0,%edi
  402a69:	e8 02 fb ff ff       	callq  402570 <_ZNSt8ios_base4InitC1Ev@plt>
  402a6e:	ba b0 70 60 00       	mov    $0x6070b0,%edx
  402a73:	be d0 74 60 00       	mov    $0x6074d0,%esi
  402a78:	bf b0 25 40 00       	mov    $0x4025b0,%edi
  402a7d:	e8 1e fb ff ff       	callq  4025a0 <__cxa_atexit@plt>
using namespace std;

#define ARRAY_SIZE(array) (sizeof((array))/sizeof((array[0])))
float dummyOut[100];
int dummyOutIndex = 0;
vector<std::chrono::duration<double, std::ratio<1, 1000>>> gSlowSimpleUpdateExampleTimers;
  402a82:	ba b0 70 60 00       	mov    $0x6070b0,%edx
  402a87:	be 20 73 60 00       	mov    $0x607320,%esi
  402a8c:	bf 80 4b 40 00       	mov    $0x404b80,%edi
  402a91:	48 c7 05 84 48 20 00 	movq   $0x0,0x204884(%rip)        # 607320 <gSlowSimpleUpdateExampleTimers>
  402a98:	00 00 00 00 
  402a9c:	48 c7 05 81 48 20 00 	movq   $0x0,0x204881(%rip)        # 607328 <gSlowSimpleUpdateExampleTimers+0x8>
  402aa3:	00 00 00 00 
  402aa7:	48 c7 05 7e 48 20 00 	movq   $0x0,0x20487e(%rip)        # 607330 <gSlowSimpleUpdateExampleTimers+0x10>
  402aae:	00 00 00 00 
  402ab2:	e8 e9 fa ff ff       	callq  4025a0 <__cxa_atexit@plt>
vector<std::chrono::duration<double, std::ratio<1, 1000>>> gSlowComplicatedUpdateExampleTimers;
  402ab7:	ba b0 70 60 00       	mov    $0x6070b0,%edx
  402abc:	be 00 73 60 00       	mov    $0x607300,%esi
  402ac1:	bf 80 4b 40 00       	mov    $0x404b80,%edi
  402ac6:	48 c7 05 2f 48 20 00 	movq   $0x0,0x20482f(%rip)        # 607300 <gSlowComplicatedUpdateExampleTimers>
  402acd:	00 00 00 00 
  402ad1:	48 c7 05 2c 48 20 00 	movq   $0x0,0x20482c(%rip)        # 607308 <gSlowComplicatedUpdateExampleTimers+0x8>
  402ad8:	00 00 00 00 
  402adc:	48 c7 05 29 48 20 00 	movq   $0x0,0x204829(%rip)        # 607310 <gSlowComplicatedUpdateExampleTimers+0x10>
  402ae3:	00 00 00 00 
  402ae7:	e8 b4 fa ff ff       	callq  4025a0 <__cxa_atexit@plt>
vector<std::chrono::duration<double, std::ratio<1, 1000>>> gFastUpdateExampleTimers;
  402aec:	ba b0 70 60 00       	mov    $0x6070b0,%edx
  402af1:	be e0 72 60 00       	mov    $0x6072e0,%esi
  402af6:	bf 80 4b 40 00       	mov    $0x404b80,%edi
  402afb:	48 c7 05 da 47 20 00 	movq   $0x0,0x2047da(%rip)        # 6072e0 <gFastUpdateExampleTimers>
  402b02:	00 00 00 00 
  402b06:	48 c7 05 d7 47 20 00 	movq   $0x0,0x2047d7(%rip)        # 6072e8 <gFastUpdateExampleTimers+0x8>
  402b0d:	00 00 00 00 
  402b11:	48 c7 05 d4 47 20 00 	movq   $0x0,0x2047d4(%rip)        # 6072f0 <gFastUpdateExampleTimers+0x10>
  402b18:	00 00 00 00 
  402b1c:	e8 7f fa ff ff       	callq  4025a0 <__cxa_atexit@plt>
  402b21:	48 c7 05 94 47 20 00 	movq   $0x0,0x204794(%rip)        # 6072c0 <gMethodPointerUpdateExampleTimers>
  402b28:	00 00 00 00 
  402b2c:	48 c7 05 91 47 20 00 	movq   $0x0,0x204791(%rip)        # 6072c8 <gMethodPointerUpdateExampleTimers+0x8>
  402b33:	00 00 00 00 
#ifdef __GNUC__
vector<std::chrono::duration<double, std::ratio<1, 1000>>> gMethodPointerUpdateExampleTimers;
  402b37:	ba b0 70 60 00       	mov    $0x6070b0,%edx
  402b3c:	48 c7 05 89 47 20 00 	movq   $0x0,0x204789(%rip)        # 6072d0 <gMethodPointerUpdateExampleTimers+0x10>
  402b43:	00 00 00 00 
  402b47:	be c0 72 60 00       	mov    $0x6072c0,%esi
  402b4c:	bf 80 4b 40 00       	mov    $0x404b80,%edi
	{
		cout << "gMethodPointerUpdateExampleTimers ms " << t.count() << endl;
	}
#endif
	return 0;
}
  402b51:	48 83 c4 08          	add    $0x8,%rsp
int dummyOutIndex = 0;
vector<std::chrono::duration<double, std::ratio<1, 1000>>> gSlowSimpleUpdateExampleTimers;
vector<std::chrono::duration<double, std::ratio<1, 1000>>> gSlowComplicatedUpdateExampleTimers;
vector<std::chrono::duration<double, std::ratio<1, 1000>>> gFastUpdateExampleTimers;
#ifdef __GNUC__
vector<std::chrono::duration<double, std::ratio<1, 1000>>> gMethodPointerUpdateExampleTimers;
  402b55:	e9 46 fa ff ff       	jmpq   4025a0 <__cxa_atexit@plt>

0000000000402b5a <_start>:
  402b5a:	31 ed                	xor    %ebp,%ebp
  402b5c:	49 89 d1             	mov    %rdx,%r9
  402b5f:	5e                   	pop    %rsi
  402b60:	48 89 e2             	mov    %rsp,%rdx
  402b63:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  402b67:	50                   	push   %rax
  402b68:	54                   	push   %rsp
  402b69:	49 c7 c0 70 54 40 00 	mov    $0x405470,%r8
  402b70:	48 c7 c1 00 54 40 00 	mov    $0x405400,%rcx
  402b77:	48 c7 c7 e0 26 40 00 	mov    $0x4026e0,%rdi
  402b7e:	e8 fd f9 ff ff       	callq  402580 <__libc_start_main@plt>
  402b83:	f4                   	hlt    
  402b84:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  402b8b:	00 00 00 
  402b8e:	66 90                	xchg   %ax,%ax

0000000000402b90 <deregister_tm_clones>:
  402b90:	b8 bf 70 60 00       	mov    $0x6070bf,%eax
  402b95:	55                   	push   %rbp
  402b96:	48 2d b8 70 60 00    	sub    $0x6070b8,%rax
  402b9c:	48 83 f8 0e          	cmp    $0xe,%rax
  402ba0:	48 89 e5             	mov    %rsp,%rbp
  402ba3:	77 02                	ja     402ba7 <deregister_tm_clones+0x17>
  402ba5:	5d                   	pop    %rbp
  402ba6:	c3                   	retq   
  402ba7:	b8 00 00 00 00       	mov    $0x0,%eax
  402bac:	48 85 c0             	test   %rax,%rax
  402baf:	74 f4                	je     402ba5 <deregister_tm_clones+0x15>
  402bb1:	5d                   	pop    %rbp
  402bb2:	bf b8 70 60 00       	mov    $0x6070b8,%edi
  402bb7:	ff e0                	jmpq   *%rax
  402bb9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000402bc0 <register_tm_clones>:
  402bc0:	b8 b8 70 60 00       	mov    $0x6070b8,%eax
  402bc5:	55                   	push   %rbp
  402bc6:	48 2d b8 70 60 00    	sub    $0x6070b8,%rax
  402bcc:	48 c1 f8 03          	sar    $0x3,%rax
  402bd0:	48 89 e5             	mov    %rsp,%rbp
  402bd3:	48 89 c2             	mov    %rax,%rdx
  402bd6:	48 c1 ea 3f          	shr    $0x3f,%rdx
  402bda:	48 01 d0             	add    %rdx,%rax
  402bdd:	48 d1 f8             	sar    %rax
  402be0:	75 02                	jne    402be4 <register_tm_clones+0x24>
  402be2:	5d                   	pop    %rbp
  402be3:	c3                   	retq   
  402be4:	ba 00 00 00 00       	mov    $0x0,%edx
  402be9:	48 85 d2             	test   %rdx,%rdx
  402bec:	74 f4                	je     402be2 <register_tm_clones+0x22>
  402bee:	5d                   	pop    %rbp
  402bef:	48 89 c6             	mov    %rax,%rsi
  402bf2:	bf b8 70 60 00       	mov    $0x6070b8,%edi
  402bf7:	ff e2                	jmpq   *%rdx
  402bf9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000402c00 <__do_global_dtors_aux>:
  402c00:	80 3d 81 46 20 00 00 	cmpb   $0x0,0x204681(%rip)        # 607288 <completed.6973>
  402c07:	75 11                	jne    402c1a <__do_global_dtors_aux+0x1a>
  402c09:	55                   	push   %rbp
  402c0a:	48 89 e5             	mov    %rsp,%rbp
  402c0d:	e8 7e ff ff ff       	callq  402b90 <deregister_tm_clones>
  402c12:	5d                   	pop    %rbp
  402c13:	c6 05 6e 46 20 00 01 	movb   $0x1,0x20466e(%rip)        # 607288 <completed.6973>
  402c1a:	f3 c3                	repz retq 
  402c1c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000402c20 <frame_dummy>:
  402c20:	48 83 3d d8 41 20 00 	cmpq   $0x0,0x2041d8(%rip)        # 606e00 <__JCR_END__>
  402c27:	00 
  402c28:	74 1e                	je     402c48 <frame_dummy+0x28>
  402c2a:	b8 00 00 00 00       	mov    $0x0,%eax
  402c2f:	48 85 c0             	test   %rax,%rax
  402c32:	74 14                	je     402c48 <frame_dummy+0x28>
  402c34:	55                   	push   %rbp
  402c35:	bf 00 6e 60 00       	mov    $0x606e00,%edi
  402c3a:	48 89 e5             	mov    %rsp,%rbp
  402c3d:	ff d0                	callq  *%rax
  402c3f:	5d                   	pop    %rbp
  402c40:	e9 7b ff ff ff       	jmpq   402bc0 <register_tm_clones>
  402c45:	0f 1f 00             	nopl   (%rax)
  402c48:	e9 73 ff ff ff       	jmpq   402bc0 <register_tm_clones>
  402c4d:	0f 1f 00             	nopl   (%rax)

0000000000402c50 <_ZN21entity_lerp_fast_implD1Ev>:
entity_lerp_fast_impl::entity_lerp_fast_impl(float s, float d)
{
	s_positions.push_back({ s,d });
}

 entity_lerp_fast_impl::~entity_lerp_fast_impl()
  402c50:	48 c7 07 d0 56 40 00 	movq   $0x4056d0,(%rdi)
       *  called.
       */
      void
      pop_back()
      {
	--this->_M_impl._M_finish;
  402c57:	48 83 2d 39 46 20 00 	subq   $0x8,0x204639(%rip)        # 607298 <_ZL11s_positions+0x8>
  402c5e:	08 
	const long long* m_typedata;
	entity(const long long* typedata) :m_typedata(typedata) {}

	virtual void Update(float t) const = 0;
	virtual int GetType() const = 0;
	virtual ~entity() {}
  402c5f:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)
  402c66:	c3                   	retq   
  402c67:	90                   	nop
  402c68:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  402c6f:	00 

0000000000402c70 <_ZNK21entity_lerp_fast_impl7GetTypeEv>:
}

int  entity_lerp_fast_impl::GetType() const 
{
	return type;
}
  402c70:	b8 02 00 00 00       	mov    $0x2,%eax
  402c75:	c3                   	retq   
  402c76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  402c7d:	00 00 00 

0000000000402c80 <_ZNK21entity_lerp_fast_impl6UpdateEf>:

void  entity_lerp_fast_impl::Update(float t) const 
{
  402c80:	f3 c3                	repz retq 
  402c82:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402c89:	1f 84 00 00 00 00 00 

0000000000402c90 <_ZN21entity_lerp_fast_implD0Ev>:
entity_lerp_fast_impl::entity_lerp_fast_impl(float s, float d)
{
	s_positions.push_back({ s,d });
}

 entity_lerp_fast_impl::~entity_lerp_fast_impl()
  402c90:	48 c7 07 d0 56 40 00 	movq   $0x4056d0,(%rdi)
  402c97:	48 83 2d f9 45 20 00 	subq   $0x8,0x2045f9(%rip)        # 607298 <_ZL11s_positions+0x8>
  402c9e:	08 
  402c9f:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)
{
	s_positions.pop_back();
}
  402ca6:	e9 a5 f8 ff ff       	jmpq   402550 <_ZdlPv@plt>
  402cab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000402cb0 <_Z4lerpfff>:
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402cb0:	f3 0f 5c ca          	subss  %xmm2,%xmm1
  402cb4:	f3 0f 59 c8          	mulss  %xmm0,%xmm1
  402cb8:	f3 0f 58 ca          	addss  %xmm2,%xmm1
}
  402cbc:	0f 28 c1             	movaps %xmm1,%xmm0
  402cbf:	c3                   	retq   

0000000000402cc0 <_ZN21entity_lerp_fast_impl9UpdateAllEf>:
  402cc0:	4c 8b 0d c9 45 20 00 	mov    0x2045c9(%rip),%r9        # 607290 <_ZL11s_positions>
  402cc7:	48 8b 3d ca 45 20 00 	mov    0x2045ca(%rip),%rdi        # 607298 <_ZL11s_positions+0x8>
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402cce:	49 b8 c3 f5 28 5c 8f 	movabs $0x28f5c28f5c28f5c3,%r8
  402cd5:	c2 f5 28 
  402cd8:	44 8b 15 59 46 20 00 	mov    0x204659(%rip),%r10d        # 607338 <dummyOutIndex>
	assert(0); // don't call. 
}

void  entity_lerp_fast_impl::UpdateAll(float t)
{
	for (auto& pos : s_positions)
  402cdf:	49 39 f9             	cmp    %rdi,%r9
  402ce2:	4c 89 c9             	mov    %r9,%rcx
  402ce5:	49 63 f2             	movslq %r10d,%rsi
  402ce8:	74 6a                	je     402d54 <_ZN21entity_lerp_fast_impl9UpdateAllEf+0x94>
  402cea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402cf0:	48 89 f2             	mov    %rsi,%rdx
  402cf3:	f3 0f 10 51 04       	movss  0x4(%rcx),%xmm2
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402cf8:	f3 0f 10 09          	movss  (%rcx),%xmm1
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402cfc:	48 c1 ea 02          	shr    $0x2,%rdx
  402d00:	48 89 d0             	mov    %rdx,%rax
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402d03:	f3 0f 5c ca          	subss  %xmm2,%xmm1
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
	++_M_current;
  402d07:	48 83 c1 08          	add    $0x8,%rcx
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402d0b:	49 f7 e0             	mul    %r8
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402d0e:	f3 0f 59 c8          	mulss  %xmm0,%xmm1
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402d12:	48 c1 ea 02          	shr    $0x2,%rdx
  402d16:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax
  402d1a:	48 89 f2             	mov    %rsi,%rdx
  402d1d:	48 83 c6 01          	add    $0x1,%rsi
  402d21:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402d25:	f3 0f 58 ca          	addss  %xmm2,%xmm1
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402d29:	48 c1 e0 02          	shl    $0x2,%rax
  402d2d:	48 29 c2             	sub    %rax,%rdx
	assert(0); // don't call. 
}

void  entity_lerp_fast_impl::UpdateAll(float t)
{
	for (auto& pos : s_positions)
  402d30:	48 39 cf             	cmp    %rcx,%rdi
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402d33:	f3 0f 11 0c 95 40 73 	movss  %xmm1,0x607340(,%rdx,4)
  402d3a:	60 00 
	assert(0); // don't call. 
}

void  entity_lerp_fast_impl::UpdateAll(float t)
{
	for (auto& pos : s_positions)
  402d3c:	75 b2                	jne    402cf0 <_ZN21entity_lerp_fast_impl9UpdateAllEf+0x30>
  402d3e:	49 83 c1 08          	add    $0x8,%r9
  402d42:	4c 29 cf             	sub    %r9,%rdi
  402d45:	48 c1 ef 03          	shr    $0x3,%rdi
  402d49:	41 8d 44 3a 01       	lea    0x1(%r10,%rdi,1),%eax
  402d4e:	89 05 e4 45 20 00    	mov    %eax,0x2045e4(%rip)        # 607338 <dummyOutIndex>
  402d54:	f3 c3                	repz retq 
  402d56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  402d5d:	00 00 00 

0000000000402d60 <_ZN16entity_lerp_fast9UpdateAllEf>:
      typedef typename __traits_type::pointer   	pointer;

      _GLIBCXX_CONSTEXPR __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
  402d60:	4c 8b 0d 29 45 20 00 	mov    0x204529(%rip),%r9        # 607290 <_ZL11s_positions>
  402d67:	48 8b 3d 2a 45 20 00 	mov    0x20452a(%rip),%rdi        # 607298 <_ZL11s_positions+0x8>
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402d6e:	49 b8 c3 f5 28 5c 8f 	movabs $0x28f5c28f5c28f5c3,%r8
  402d75:	c2 f5 28 
  402d78:	44 8b 15 b9 45 20 00 	mov    0x2045b9(%rip),%r10d        # 607338 <dummyOutIndex>
	assert(0); // don't call. 
}

void  entity_lerp_fast_impl::UpdateAll(float t)
{
	for (auto& pos : s_positions)
  402d7f:	49 39 f9             	cmp    %rdi,%r9
  402d82:	4c 89 c9             	mov    %r9,%rcx
  402d85:	49 63 f2             	movslq %r10d,%rsi
  402d88:	74 6a                	je     402df4 <_ZN16entity_lerp_fast9UpdateAllEf+0x94>
  402d8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402d90:	48 89 f2             	mov    %rsi,%rdx
  402d93:	f3 0f 10 51 04       	movss  0x4(%rcx),%xmm2
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402d98:	f3 0f 10 09          	movss  (%rcx),%xmm1
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402d9c:	48 c1 ea 02          	shr    $0x2,%rdx
  402da0:	48 89 d0             	mov    %rdx,%rax
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402da3:	f3 0f 5c ca          	subss  %xmm2,%xmm1
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
	++_M_current;
  402da7:	48 83 c1 08          	add    $0x8,%rcx
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402dab:	49 f7 e0             	mul    %r8
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402dae:	f3 0f 59 c8          	mulss  %xmm0,%xmm1
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402db2:	48 c1 ea 02          	shr    $0x2,%rdx
  402db6:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax
  402dba:	48 89 f2             	mov    %rsi,%rdx
  402dbd:	48 83 c6 01          	add    $0x1,%rsi
  402dc1:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402dc5:	f3 0f 58 ca          	addss  %xmm2,%xmm1
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402dc9:	48 c1 e0 02          	shl    $0x2,%rax
  402dcd:	48 29 c2             	sub    %rax,%rdx
	assert(0); // don't call. 
}

void  entity_lerp_fast_impl::UpdateAll(float t)
{
	for (auto& pos : s_positions)
  402dd0:	48 39 cf             	cmp    %rcx,%rdi
#ifdef PRINT
		cout << "fast_lerp ";
		cout << lerp(t, pos.x, pos.y);
		cout << endl;
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, pos.x, pos.y);
  402dd3:	f3 0f 11 0c 95 40 73 	movss  %xmm1,0x607340(,%rdx,4)
  402dda:	60 00 
	assert(0); // don't call. 
}

void  entity_lerp_fast_impl::UpdateAll(float t)
{
	for (auto& pos : s_positions)
  402ddc:	75 b2                	jne    402d90 <_ZN16entity_lerp_fast9UpdateAllEf+0x30>
  402dde:	49 83 c1 08          	add    $0x8,%r9
  402de2:	4c 29 cf             	sub    %r9,%rdi
  402de5:	48 c1 ef 03          	shr    $0x3,%rdi
  402de9:	41 8d 44 3a 01       	lea    0x1(%r10,%rdi,1),%eax
  402dee:	89 05 44 45 20 00    	mov    %eax,0x204544(%rip)        # 607338 <dummyOutIndex>
  402df4:	f3 c3                	repz retq 
  402df6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  402dfd:	00 00 00 

0000000000402e00 <_Z23create_entity_lerp_slowff>:
	return new entity_lerp_fast_impl(p1, p2);
}


entity_lerp_slow* create_entity_lerp_slow(float p1, float p2)
{
  402e00:	48 83 ec 18          	sub    $0x18,%rsp
	return new entity_lerp_slow_impl(p1, p2);
  402e04:	bf 18 00 00 00       	mov    $0x18,%edi
	return new entity_lerp_fast_impl(p1, p2);
}


entity_lerp_slow* create_entity_lerp_slow(float p1, float p2)
{
  402e09:	f3 0f 11 44 24 0c    	movss  %xmm0,0xc(%rsp)
  402e0f:	f3 0f 11 4c 24 08    	movss  %xmm1,0x8(%rsp)
	return new entity_lerp_slow_impl(p1, p2);
  402e15:	e8 06 f8 ff ff       	callq  402620 <_Znwm@plt>
public:
	const static int type = 1;

	entity_lerp_slow_impl(float s, float d)
		:m_s(s)
		, m_d(d)
  402e1a:	f3 0f 10 44 24 0c    	movss  0xc(%rsp),%xmm0
  402e20:	f3 0f 10 4c 24 08    	movss  0x8(%rsp),%xmm1

class entity
{
public:
	const long long* m_typedata;
	entity(const long long* typedata) :m_typedata(typedata) {}
  402e26:	48 c7 40 08 00 57 40 	movq   $0x405700,0x8(%rax)
  402e2d:	00 
  402e2e:	48 c7 00 90 56 40 00 	movq   $0x405690,(%rax)
  402e35:	f3 0f 11 40 10       	movss  %xmm0,0x10(%rax)
  402e3a:	f3 0f 11 48 14       	movss  %xmm1,0x14(%rax)


entity_lerp_slow* create_entity_lerp_slow(float p1, float p2)
{
	return new entity_lerp_slow_impl(p1, p2);
}
  402e3f:	48 83 c4 18          	add    $0x18,%rsp
  402e43:	c3                   	retq   
  402e44:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402e4b:	00 00 00 00 00 

0000000000402e50 <_ZN21entity_lerp_fast_implC1Eff>:

static std::vector<Pos> s_positions;

const long long entity_lerp_fast_impl::type = 2;

entity_lerp_fast_impl::entity_lerp_fast_impl(float s, float d)
  402e50:	53                   	push   %rbx
  402e51:	48 89 fb             	mov    %rdi,%rbx
  402e54:	48 83 ec 10          	sub    $0x10,%rsp
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  402e58:	48 8b 05 39 44 20 00 	mov    0x204439(%rip),%rax        # 607298 <_ZL11s_positions+0x8>
  402e5f:	48 3b 05 3a 44 20 00 	cmp    0x20443a(%rip),%rax        # 6072a0 <_ZL11s_positions+0x10>
  402e66:	48 c7 47 08 f8 56 40 	movq   $0x4056f8,0x8(%rdi)
  402e6d:	00 
  402e6e:	48 c7 07 d0 56 40 00 	movq   $0x4056d0,(%rdi)
{
	s_positions.push_back({ s,d });
  402e75:	f3 0f 11 04 24       	movss  %xmm0,(%rsp)
  402e7a:	f3 0f 11 4c 24 04    	movss  %xmm1,0x4(%rsp)
  402e80:	74 1e                	je     402ea0 <_ZN21entity_lerp_fast_implC1Eff+0x50>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  402e82:	48 85 c0             	test   %rax,%rax
  402e85:	74 07                	je     402e8e <_ZN21entity_lerp_fast_implC1Eff+0x3e>
  402e87:	48 8b 14 24          	mov    (%rsp),%rdx
  402e8b:	48 89 10             	mov    %rdx,(%rax)
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  402e8e:	48 83 c0 08          	add    $0x8,%rax
  402e92:	48 89 05 ff 43 20 00 	mov    %rax,0x2043ff(%rip)        # 607298 <_ZL11s_positions+0x8>
}
  402e99:	48 83 c4 10          	add    $0x10,%rsp
  402e9d:	5b                   	pop    %rbx
  402e9e:	c3                   	retq   
  402e9f:	90                   	nop
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  402ea0:	48 89 e6             	mov    %rsp,%rsi
  402ea3:	bf 90 72 60 00       	mov    $0x607290,%edi
  402ea8:	e8 d3 01 00 00       	callq  403080 <_ZNSt6vectorI3PosSaIS0_EE19_M_emplace_back_auxIIS0_EEEvDpOT_>
  402ead:	eb ea                	jmp    402e99 <_ZN21entity_lerp_fast_implC1Eff+0x49>

	virtual void Update(float t) const = 0;
	virtual int GetType() const = 0;
	virtual ~entity() {}
  402eaf:	48 c7 03 d0 55 40 00 	movq   $0x4055d0,(%rbx)
  402eb6:	48 89 c7             	mov    %rax,%rdi
  402eb9:	e8 72 f7 ff ff       	callq  402630 <_Unwind_Resume@plt>
  402ebe:	66 90                	xchg   %ax,%ax

0000000000402ec0 <_Z23create_entity_lerp_fastff>:
{
	entity_lerp_fast_impl::UpdateAll(t);
}

entity_lerp_fast* create_entity_lerp_fast(float p1, float p2)
{
  402ec0:	55                   	push   %rbp
	return new entity_lerp_fast_impl(p1, p2);
  402ec1:	bf 10 00 00 00       	mov    $0x10,%edi
{
	entity_lerp_fast_impl::UpdateAll(t);
}

entity_lerp_fast* create_entity_lerp_fast(float p1, float p2)
{
  402ec6:	53                   	push   %rbx
  402ec7:	48 83 ec 28          	sub    $0x28,%rsp
  402ecb:	f3 0f 11 44 24 0c    	movss  %xmm0,0xc(%rsp)
  402ed1:	f3 0f 11 4c 24 08    	movss  %xmm1,0x8(%rsp)
	return new entity_lerp_fast_impl(p1, p2);
  402ed7:	e8 44 f7 ff ff       	callq  402620 <_Znwm@plt>

static std::vector<Pos> s_positions;

const long long entity_lerp_fast_impl::type = 2;

entity_lerp_fast_impl::entity_lerp_fast_impl(float s, float d)
  402edc:	48 c7 00 d0 56 40 00 	movq   $0x4056d0,(%rax)
	entity_lerp_fast_impl::UpdateAll(t);
}

entity_lerp_fast* create_entity_lerp_fast(float p1, float p2)
{
	return new entity_lerp_fast_impl(p1, p2);
  402ee3:	48 89 c3             	mov    %rax,%rbx

class entity
{
public:
	const long long* m_typedata;
	entity(const long long* typedata) :m_typedata(typedata) {}
  402ee6:	48 c7 40 08 f8 56 40 	movq   $0x4056f8,0x8(%rax)
  402eed:	00 
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  402eee:	48 8b 05 a3 43 20 00 	mov    0x2043a3(%rip),%rax        # 607298 <_ZL11s_positions+0x8>
  402ef5:	48 3b 05 a4 43 20 00 	cmp    0x2043a4(%rip),%rax        # 6072a0 <_ZL11s_positions+0x10>

const long long entity_lerp_fast_impl::type = 2;

entity_lerp_fast_impl::entity_lerp_fast_impl(float s, float d)
{
	s_positions.push_back({ s,d });
  402efc:	f3 0f 10 44 24 0c    	movss  0xc(%rsp),%xmm0
  402f02:	f3 0f 10 4c 24 08    	movss  0x8(%rsp),%xmm1
  402f08:	f3 0f 11 44 24 10    	movss  %xmm0,0x10(%rsp)
  402f0e:	f3 0f 11 4c 24 14    	movss  %xmm1,0x14(%rsp)
  402f14:	74 2a                	je     402f40 <_Z23create_entity_lerp_fastff+0x80>
  402f16:	48 85 c0             	test   %rax,%rax
  402f19:	74 08                	je     402f23 <_Z23create_entity_lerp_fastff+0x63>
  402f1b:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  402f20:	48 89 10             	mov    %rdx,(%rax)
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  402f23:	48 83 c0 08          	add    $0x8,%rax
  402f27:	48 89 05 6a 43 20 00 	mov    %rax,0x20436a(%rip)        # 607298 <_ZL11s_positions+0x8>
}

entity_lerp_fast* create_entity_lerp_fast(float p1, float p2)
{
	return new entity_lerp_fast_impl(p1, p2);
}
  402f2e:	48 83 c4 28          	add    $0x28,%rsp
  402f32:	48 89 d8             	mov    %rbx,%rax
  402f35:	5b                   	pop    %rbx
  402f36:	5d                   	pop    %rbp
  402f37:	c3                   	retq   
  402f38:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  402f3f:	00 
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  402f40:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
  402f45:	bf 90 72 60 00       	mov    $0x607290,%edi
  402f4a:	e8 31 01 00 00       	callq  403080 <_ZNSt6vectorI3PosSaIS0_EE19_M_emplace_back_auxIIS0_EEEvDpOT_>
  402f4f:	eb dd                	jmp    402f2e <_Z23create_entity_lerp_fastff+0x6e>
  402f51:	48 89 c5             	mov    %rax,%rbp
	entity_lerp_fast_impl::UpdateAll(t);
}

entity_lerp_fast* create_entity_lerp_fast(float p1, float p2)
{
	return new entity_lerp_fast_impl(p1, p2);
  402f54:	48 89 df             	mov    %rbx,%rdi

	virtual void Update(float t) const = 0;
	virtual int GetType() const = 0;
	virtual ~entity() {}
  402f57:	48 c7 03 d0 55 40 00 	movq   $0x4055d0,(%rbx)
  402f5e:	e8 ed f5 ff ff       	callq  402550 <_ZdlPv@plt>
  402f63:	48 89 ef             	mov    %rbp,%rdi
  402f66:	e8 c5 f6 ff ff       	callq  402630 <_Unwind_Resume@plt>
  402f6b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000402f70 <_ZN6entityD1Ev>:
  402f70:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)
  402f77:	c3                   	retq   
  402f78:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  402f7f:	00 

0000000000402f80 <_ZN16entity_lerp_slowD1Ev>:
  402f80:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)
  402f87:	c3                   	retq   
  402f88:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  402f8f:	00 

0000000000402f90 <_ZN21entity_lerp_slow_implD1Ev>:
  402f90:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)
  402f97:	c3                   	retq   
  402f98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  402f9f:	00 

0000000000402fa0 <_ZNK21entity_lerp_slow_impl7GetTypeEv>:
	virtual ~entity_lerp_slow_impl() {}

	int GetType() const override
	{
		return type;
	}
  402fa0:	b8 01 00 00 00       	mov    $0x1,%eax
  402fa5:	c3                   	retq   
  402fa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  402fad:	00 00 00 

0000000000402fb0 <_ZNK21entity_lerp_slow_impl6UpdateEf>:
	{
#ifdef PRINT
		cout << "lerp ";
		cout << lerp(t, m_s, m_d);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, m_s, m_d);
  402fb0:	8b 0d 82 43 20 00    	mov    0x204382(%rip),%ecx        # 607338 <dummyOutIndex>
  402fb6:	f3 0f 10 57 14       	movss  0x14(%rdi),%xmm2
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402fbb:	f3 0f 10 4f 10       	movss  0x10(%rdi),%xmm1
	{
#ifdef PRINT
		cout << "lerp ";
		cout << lerp(t, m_s, m_d);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, m_s, m_d);
  402fc0:	48 ba c3 f5 28 5c 8f 	movabs $0x28f5c28f5c28f5c3,%rdx
  402fc7:	c2 f5 28 
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402fca:	f3 0f 5c ca          	subss  %xmm2,%xmm1
	{
#ifdef PRINT
		cout << "lerp ";
		cout << lerp(t, m_s, m_d);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, m_s, m_d);
  402fce:	48 63 f1             	movslq %ecx,%rsi
		dummyOutIndex++;
  402fd1:	83 c1 01             	add    $0x1,%ecx
	{
#ifdef PRINT
		cout << "lerp ";
		cout << lerp(t, m_s, m_d);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, m_s, m_d);
  402fd4:	48 89 f0             	mov    %rsi,%rax
		dummyOutIndex++;
  402fd7:	89 0d 5b 43 20 00    	mov    %ecx,0x20435b(%rip)        # 607338 <dummyOutIndex>
	{
#ifdef PRINT
		cout << "lerp ";
		cout << lerp(t, m_s, m_d);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, m_s, m_d);
  402fdd:	48 c1 e8 02          	shr    $0x2,%rax
  402fe1:	48 f7 e2             	mul    %rdx
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402fe4:	f3 0f 59 c1          	mulss  %xmm1,%xmm0
	{
#ifdef PRINT
		cout << "lerp ";
		cout << lerp(t, m_s, m_d);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, m_s, m_d);
  402fe8:	48 c1 ea 02          	shr    $0x2,%rdx
extern int dummyOutIndex;


float lerp(float t, float s, float d)
{
	return t * (s - d) + d;
  402fec:	f3 0f 58 c2          	addss  %xmm2,%xmm0
	{
#ifdef PRINT
		cout << "lerp ";
		cout << lerp(t, m_s, m_d);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = lerp(t, m_s, m_d);
  402ff0:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax
  402ff4:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
  402ff8:	48 c1 e0 02          	shl    $0x2,%rax
  402ffc:	48 29 c6             	sub    %rax,%rsi
  402fff:	f3 0f 11 04 b5 40 73 	movss  %xmm0,0x607340(,%rsi,4)
  403006:	60 00 
		dummyOutIndex++;
  403008:	c3                   	retq   
  403009:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000403010 <_ZN16entity_lerp_fastD1Ev>:
  403010:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)
  403017:	c3                   	retq   
  403018:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40301f:	00 

0000000000403020 <_ZN6entityD0Ev>:
  403020:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)
  403027:	e9 24 f5 ff ff       	jmpq   402550 <_ZdlPv@plt>
  40302c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000403030 <_ZN16entity_lerp_slowD0Ev>:
  403030:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)
#pragma once
class entity_lerp_slow : public entity
  403037:	e9 14 f5 ff ff       	jmpq   402550 <_ZdlPv@plt>
  40303c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000403040 <_ZN21entity_lerp_slow_implD0Ev>:
  403040:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)

	entity_lerp_slow_impl(float s, float d)
		:m_s(s)
		, m_d(d)
	{}
	virtual ~entity_lerp_slow_impl() {}
  403047:	e9 04 f5 ff ff       	jmpq   402550 <_ZdlPv@plt>
  40304c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000403050 <_ZN16entity_lerp_fastD0Ev>:
  403050:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)

	virtual int GetType() const override = 0;
	virtual void Update(float t) const override = 0;
};

class entity_lerp_fast : public entity
  403057:	e9 f4 f4 ff ff       	jmpq   402550 <_ZdlPv@plt>
  40305c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000403060 <_ZNSt6vectorI3PosSaIS0_EED1Ev>:
      }
#endif

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  403060:	48 8b 3f             	mov    (%rdi),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  403063:	48 85 ff             	test   %rdi,%rdi
  403066:	74 08                	je     403070 <_ZNSt6vectorI3PosSaIS0_EED1Ev+0x10>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  403068:	e9 e3 f4 ff ff       	jmpq   402550 <_ZdlPv@plt>
  40306d:	0f 1f 00             	nopl   (%rax)
  403070:	f3 c3                	repz retq 
  403072:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  403079:	00 00 00 
  40307c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000403080 <_ZNSt6vectorI3PosSaIS0_EE19_M_emplace_back_auxIIS0_EEEvDpOT_>:

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
  403080:	41 56                	push   %r14
  403082:	49 89 f6             	mov    %rsi,%r14
  403085:	41 55                	push   %r13
  403087:	41 54                	push   %r12
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
  403089:	41 bc 08 00 00 00    	mov    $0x8,%r12d
  40308f:	55                   	push   %rbp
  403090:	53                   	push   %rbx

      // [23.2.4.2] capacity
      /**  Returns the number of elements in the %vector.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
  403091:	48 8b 57 08          	mov    0x8(%rdi),%rdx
  403095:	48 89 fb             	mov    %rdi,%rbx
  403098:	48 2b 17             	sub    (%rdi),%rdx
  40309b:	48 c1 fa 03          	sar    $0x3,%rdx
  40309f:	48 85 d2             	test   %rdx,%rdx
  4030a2:	75 6c                	jne    403110 <_ZNSt6vectorI3PosSaIS0_EE19_M_emplace_back_auxIIS0_EEEvDpOT_+0x90>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  4030a4:	4c 89 e7             	mov    %r12,%rdi
  4030a7:	e8 74 f5 ff ff       	callq  402620 <_Znwm@plt>
  4030ac:	48 8b 33             	mov    (%rbx),%rsi
  4030af:	48 89 c5             	mov    %rax,%rbp
  4030b2:	48 8b 43 08          	mov    0x8(%rbx),%rax

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  4030b6:	49 89 ed             	mov    %rbp,%r13
  4030b9:	48 29 f0             	sub    %rsi,%rax
  4030bc:	48 c1 f8 03          	sar    $0x3,%rax
	pointer __new_start(this->_M_allocate(__len));
	pointer __new_finish(__new_start);
	__try
	  {
	    _Alloc_traits::construct(this->_M_impl, __new_start + size(),
				     std::forward<_Args>(__args)...);
  4030c0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  4030c7:	00 
  4030c8:	49 01 d5             	add    %rdx,%r13
  4030cb:	74 07                	je     4030d4 <_ZNSt6vectorI3PosSaIS0_EE19_M_emplace_back_auxIIS0_EEEvDpOT_+0x54>
  4030cd:	49 8b 0e             	mov    (%r14),%rcx
  4030d0:	49 89 4d 00          	mov    %rcx,0x0(%r13)
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
	  const ptrdiff_t _Num = __last - __first;
	  if (_Num)
  4030d4:	48 85 c0             	test   %rax,%rax
  4030d7:	48 89 f7             	mov    %rsi,%rdi
  4030da:	74 0b                	je     4030e7 <_ZNSt6vectorI3PosSaIS0_EE19_M_emplace_back_auxIIS0_EEEvDpOT_+0x67>
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
  4030dc:	48 89 ef             	mov    %rbp,%rdi
  4030df:	e8 fc f4 ff ff       	callq  4025e0 <memmove@plt>
  4030e4:	48 8b 3b             	mov    (%rbx),%rdi
	    __new_finish
	      = std::__uninitialized_move_if_noexcept_a
	      (this->_M_impl._M_start, this->_M_impl._M_finish,
	       __new_start, _M_get_Tp_allocator());

	    ++__new_finish;
  4030e7:	49 83 c5 08          	add    $0x8,%r13
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  4030eb:	48 85 ff             	test   %rdi,%rdi
  4030ee:	74 05                	je     4030f5 <_ZNSt6vectorI3PosSaIS0_EE19_M_emplace_back_auxIIS0_EEEvDpOT_+0x75>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  4030f0:	e8 5b f4 ff ff       	callq  402550 <_ZdlPv@plt>
	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator());
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
  4030f5:	48 89 2b             	mov    %rbp,(%rbx)
	this->_M_impl._M_finish = __new_finish;
	this->_M_impl._M_end_of_storage = __new_start + __len;
  4030f8:	4c 01 e5             	add    %r12,%rbp
		      _M_get_Tp_allocator());
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
	this->_M_impl._M_finish = __new_finish;
  4030fb:	4c 89 6b 08          	mov    %r13,0x8(%rbx)
	this->_M_impl._M_end_of_storage = __new_start + __len;
  4030ff:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
      }
  403103:	5b                   	pop    %rbx
  403104:	5d                   	pop    %rbp
  403105:	41 5c                	pop    %r12
  403107:	41 5d                	pop    %r13
  403109:	41 5e                	pop    %r14
  40310b:	c3                   	retq   
  40310c:	0f 1f 40 00          	nopl   0x0(%rax)
      _M_check_len(size_type __n, const char* __s) const
      {
	if (max_size() - size() < __n)
	  __throw_length_error(__N(__s));

	const size_type __len = size() + std::max(size(), __n);
  403110:	48 8d 04 12          	lea    (%rdx,%rdx,1),%rax
	return (__len < size() || __len > max_size()) ? max_size() : __len;
  403114:	48 39 c2             	cmp    %rax,%rdx
  403117:	76 09                	jbe    403122 <_ZNSt6vectorI3PosSaIS0_EE19_M_emplace_back_auxIIS0_EEEvDpOT_+0xa2>
  403119:	49 c7 c4 f8 ff ff ff 	mov    $0xfffffffffffffff8,%r12
  403120:	eb 82                	jmp    4030a4 <_ZNSt6vectorI3PosSaIS0_EE19_M_emplace_back_auxIIS0_EEEvDpOT_+0x24>
  403122:	48 b9 ff ff ff ff ff 	movabs $0x1fffffffffffffff,%rcx
  403129:	ff ff 1f 
  40312c:	48 c1 e2 04          	shl    $0x4,%rdx
  403130:	49 c7 c4 f8 ff ff ff 	mov    $0xfffffffffffffff8,%r12
  403137:	48 39 c8             	cmp    %rcx,%rax
  40313a:	4c 0f 46 e2          	cmovbe %rdx,%r12
  40313e:	e9 61 ff ff ff       	jmpq   4030a4 <_ZNSt6vectorI3PosSaIS0_EE19_M_emplace_back_auxIIS0_EEEvDpOT_+0x24>
  403143:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40314a:	00 00 00 
  40314d:	0f 1f 00             	nopl   (%rax)

0000000000403150 <_Z7hermitefffff>:
extern float dummyOut[100];
extern int dummyOutIndex;

float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
  403150:	0f 28 f0             	movaps %xmm0,%xmm6
	float t3 = t2*t;
	float h1 = 2*t3 - 3*t2 + 1;
  403153:	f3 44 0f 10 05 bc 26 	movss  0x26bc(%rip),%xmm8        # 405818 <_ZN14entity_hermite4typeE+0x8>
  40315a:	00 00 
extern float dummyOut[100];
extern int dummyOutIndex;

float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
  40315c:	f3 0f 59 f0          	mulss  %xmm0,%xmm6
  403160:	f3 0f 59 f0          	mulss  %xmm0,%xmm6
	float t3 = t2*t;
  403164:	0f 28 fe             	movaps %xmm6,%xmm7
	float h1 = 2*t3 - 3*t2 + 1;
  403167:	f3 44 0f 59 c6       	mulss  %xmm6,%xmm8
extern int dummyOutIndex;

float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
	float t3 = t2*t;
  40316c:	f3 0f 59 f8          	mulss  %xmm0,%xmm7
	float h1 = 2*t3 - 3*t2 + 1;
  403170:	0f 28 ef             	movaps %xmm7,%xmm5
  403173:	f3 0f 58 ef          	addss  %xmm7,%xmm5
  403177:	f3 41 0f 5c e8       	subss  %xmm8,%xmm5
  40317c:	f3 0f 58 2d 98 26 00 	addss  0x2698(%rip),%xmm5        # 40581c <_ZN14entity_hermite4typeE+0xc>
  403183:	00 
	float h2 = -2*t3 + 3*t2;             
	float h3 = t3 - 2 * t2 + t;        
	float h4 = t3 - t2;              
	return h1*p1 + h2*p2 + h3*n1 + h4*n2;
  403184:	f3 0f 59 e9          	mulss  %xmm1,%xmm5
float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
	float t3 = t2*t;
	float h1 = 2*t3 - 3*t2 + 1;
	float h2 = -2*t3 + 3*t2;             
  403188:	f3 0f 10 0d 90 26 00 	movss  0x2690(%rip),%xmm1        # 405820 <_ZN14entity_hermite4typeE+0x10>
  40318f:	00 
  403190:	f3 0f 59 cf          	mulss  %xmm7,%xmm1
  403194:	f3 41 0f 58 c8       	addss  %xmm8,%xmm1
	float h3 = t3 - 2 * t2 + t;        
	float h4 = t3 - t2;              
	return h1*p1 + h2*p2 + h3*n1 + h4*n2;
  403199:	f3 0f 59 ca          	mulss  %xmm2,%xmm1
{
	float t2 = t*t*t;
	float t3 = t2*t;
	float h1 = 2*t3 - 3*t2 + 1;
	float h2 = -2*t3 + 3*t2;             
	float h3 = t3 - 2 * t2 + t;        
  40319d:	0f 28 d7             	movaps %xmm7,%xmm2
	float h4 = t3 - t2;              
  4031a0:	f3 0f 5c fe          	subss  %xmm6,%xmm7
	return h1*p1 + h2*p2 + h3*n1 + h4*n2;
  4031a4:	f3 0f 58 e9          	addss  %xmm1,%xmm5
{
	float t2 = t*t*t;
	float t3 = t2*t;
	float h1 = 2*t3 - 3*t2 + 1;
	float h2 = -2*t3 + 3*t2;             
	float h3 = t3 - 2 * t2 + t;        
  4031a8:	0f 28 ce             	movaps %xmm6,%xmm1
	float h4 = t3 - t2;              
	return h1*p1 + h2*p2 + h3*n1 + h4*n2;
  4031ab:	f3 0f 59 fc          	mulss  %xmm4,%xmm7
{
	float t2 = t*t*t;
	float t3 = t2*t;
	float h1 = 2*t3 - 3*t2 + 1;
	float h2 = -2*t3 + 3*t2;             
	float h3 = t3 - 2 * t2 + t;        
  4031af:	f3 0f 58 ce          	addss  %xmm6,%xmm1
  4031b3:	f3 0f 5c d1          	subss  %xmm1,%xmm2
  4031b7:	0f 28 ca             	movaps %xmm2,%xmm1
  4031ba:	f3 0f 58 c8          	addss  %xmm0,%xmm1
	float h4 = t3 - t2;              
	return h1*p1 + h2*p2 + h3*n1 + h4*n2;
  4031be:	f3 0f 59 cb          	mulss  %xmm3,%xmm1
  4031c2:	f3 0f 58 e9          	addss  %xmm1,%xmm5
  4031c6:	f3 0f 58 ef          	addss  %xmm7,%xmm5
}
  4031ca:	0f 28 c5             	movaps %xmm5,%xmm0
  4031cd:	c3                   	retq   
  4031ce:	66 90                	xchg   %ax,%ax

00000000004031d0 <_Z21create_entity_hermiteffff>:
		dummyOutIndex++;
	}
};

entity_hermite* create_entity_hermite(float p1, float p2, float n1, float n2)
{
  4031d0:	48 83 ec 18          	sub    $0x18,%rsp
	return new entity_hermite_impl(p1, p2, n1, n2);
  4031d4:	bf 20 00 00 00       	mov    $0x20,%edi
		dummyOutIndex++;
	}
};

entity_hermite* create_entity_hermite(float p1, float p2, float n1, float n2)
{
  4031d9:	f3 0f 11 44 24 0c    	movss  %xmm0,0xc(%rsp)
  4031df:	f3 0f 11 4c 24 08    	movss  %xmm1,0x8(%rsp)
  4031e5:	f3 0f 11 54 24 04    	movss  %xmm2,0x4(%rsp)
  4031eb:	f3 0f 11 1c 24       	movss  %xmm3,(%rsp)
	return new entity_hermite_impl(p1, p2, n1, n2);
  4031f0:	e8 2b f4 ff ff       	callq  402620 <_Znwm@plt>
	const static int type = 3;
	entity_hermite_impl(float p1, float p2, float n1, float n2)
		: m_p1(p1)
		, m_p2(p2)
		, m_n1(n1)
		, m_n2(n2)		
  4031f5:	f3 0f 10 44 24 0c    	movss  0xc(%rsp),%xmm0
  4031fb:	f3 0f 10 4c 24 08    	movss  0x8(%rsp),%xmm1

class entity
{
public:
	const long long* m_typedata;
	entity(const long long* typedata) :m_typedata(typedata) {}
  403201:	48 c7 40 08 10 58 40 	movq   $0x405810,0x8(%rax)
  403208:	00 
  403209:	f3 0f 10 54 24 04    	movss  0x4(%rsp),%xmm2
  40320f:	48 c7 00 f0 57 40 00 	movq   $0x4057f0,(%rax)
  403216:	f3 0f 10 1c 24       	movss  (%rsp),%xmm3
  40321b:	f3 0f 11 40 10       	movss  %xmm0,0x10(%rax)
  403220:	f3 0f 11 48 14       	movss  %xmm1,0x14(%rax)
  403225:	f3 0f 11 50 18       	movss  %xmm2,0x18(%rax)
  40322a:	f3 0f 11 58 1c       	movss  %xmm3,0x1c(%rax)
};

entity_hermite* create_entity_hermite(float p1, float p2, float n1, float n2)
{
	return new entity_hermite_impl(p1, p2, n1, n2);
  40322f:	48 83 c4 18          	add    $0x18,%rsp
  403233:	c3                   	retq   
  403234:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40323b:	00 00 00 
  40323e:	66 90                	xchg   %ax,%ax

0000000000403240 <_ZN14entity_hermiteD1Ev>:

	virtual void Update(float t) const = 0;
	virtual int GetType() const = 0;
	virtual ~entity() {}
  403240:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)
  403247:	c3                   	retq   
  403248:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40324f:	00 

0000000000403250 <_ZN19entity_hermite_implD1Ev>:
  403250:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)
  403257:	c3                   	retq   
  403258:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40325f:	00 

0000000000403260 <_ZNK19entity_hermite_impl7GetTypeEv>:
	virtual ~entity_hermite_impl() {}

	int GetType() const override
	{
		return type;
	}
  403260:	b8 03 00 00 00       	mov    $0x3,%eax
  403265:	c3                   	retq   
  403266:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40326d:	00 00 00 

0000000000403270 <_ZN14entity_hermiteD0Ev>:
  403270:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)
#pragma once
#include "entity.h"

class entity_hermite : public entity
  403277:	e9 d4 f2 ff ff       	jmpq   402550 <_ZdlPv@plt>
  40327c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000403280 <_ZN19entity_hermite_implD0Ev>:
  403280:	48 c7 07 d0 55 40 00 	movq   $0x4055d0,(%rdi)
		, m_n1(n1)
		, m_n2(n2)		
	{

	}
	virtual ~entity_hermite_impl() {}
  403287:	e9 c4 f2 ff ff       	jmpq   402550 <_ZdlPv@plt>
  40328c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000403290 <_ZNK19entity_hermite_impl6UpdateEf>:
extern float dummyOut[100];
extern int dummyOutIndex;

float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
  403290:	0f 28 d0             	movaps %xmm0,%xmm2
	{
#ifdef PRINT
		cout << "hermite ";
		cout << hermite(t, m_p1, m_p2, m_n1, m_n2);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = hermite(t, m_p1, m_p2, m_n1, m_n2);
  403293:	8b 0d 9f 40 20 00    	mov    0x20409f(%rip),%ecx        # 607338 <dummyOutIndex>
extern int dummyOutIndex;

float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
	float t3 = t2*t;
  403299:	0f 28 d8             	movaps %xmm0,%xmm3
	{
#ifdef PRINT
		cout << "hermite ";
		cout << hermite(t, m_p1, m_p2, m_n1, m_n2);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = hermite(t, m_p1, m_p2, m_n1, m_n2);
  40329c:	48 ba c3 f5 28 5c 8f 	movabs $0x28f5c28f5c28f5c3,%rdx
  4032a3:	c2 f5 28 
extern float dummyOut[100];
extern int dummyOutIndex;

float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
  4032a6:	f3 0f 59 d0          	mulss  %xmm0,%xmm2
	float t3 = t2*t;
	float h1 = 2*t3 - 3*t2 + 1;
  4032aa:	f3 0f 10 2d 66 25 00 	movss  0x2566(%rip),%xmm5        # 405818 <_ZN14entity_hermite4typeE+0x8>
  4032b1:	00 
	float h2 = -2*t3 + 3*t2;             
  4032b2:	f3 0f 10 25 66 25 00 	movss  0x2566(%rip),%xmm4        # 405820 <_ZN14entity_hermite4typeE+0x10>
  4032b9:	00 
	{
#ifdef PRINT
		cout << "hermite ";
		cout << hermite(t, m_p1, m_p2, m_n1, m_n2);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = hermite(t, m_p1, m_p2, m_n1, m_n2);
  4032ba:	48 63 f1             	movslq %ecx,%rsi
  4032bd:	48 89 f0             	mov    %rsi,%rax
		dummyOutIndex++;
  4032c0:	83 c1 01             	add    $0x1,%ecx
	{
#ifdef PRINT
		cout << "hermite ";
		cout << hermite(t, m_p1, m_p2, m_n1, m_n2);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = hermite(t, m_p1, m_p2, m_n1, m_n2);
  4032c3:	48 c1 e8 02          	shr    $0x2,%rax
		dummyOutIndex++;
  4032c7:	89 0d 6b 40 20 00    	mov    %ecx,0x20406b(%rip)        # 607338 <dummyOutIndex>
extern float dummyOut[100];
extern int dummyOutIndex;

float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
  4032cd:	f3 0f 59 d0          	mulss  %xmm0,%xmm2
	{
#ifdef PRINT
		cout << "hermite ";
		cout << hermite(t, m_p1, m_p2, m_n1, m_n2);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = hermite(t, m_p1, m_p2, m_n1, m_n2);
  4032d1:	48 f7 e2             	mul    %rdx
extern int dummyOutIndex;

float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
	float t3 = t2*t;
  4032d4:	f3 0f 59 da          	mulss  %xmm2,%xmm3
	float h1 = 2*t3 - 3*t2 + 1;
  4032d8:	f3 0f 59 ea          	mulss  %xmm2,%xmm5
	{
#ifdef PRINT
		cout << "hermite ";
		cout << hermite(t, m_p1, m_p2, m_n1, m_n2);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = hermite(t, m_p1, m_p2, m_n1, m_n2);
  4032dc:	48 c1 ea 02          	shr    $0x2,%rdx
  4032e0:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax

float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
	float t3 = t2*t;
	float h1 = 2*t3 - 3*t2 + 1;
  4032e4:	0f 28 cb             	movaps %xmm3,%xmm1
	float h2 = -2*t3 + 3*t2;             
  4032e7:	f3 0f 59 e3          	mulss  %xmm3,%xmm4
	float h3 = t3 - 2 * t2 + t;        
  4032eb:	0f 28 f3             	movaps %xmm3,%xmm6
	{
#ifdef PRINT
		cout << "hermite ";
		cout << hermite(t, m_p1, m_p2, m_n1, m_n2);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = hermite(t, m_p1, m_p2, m_n1, m_n2);
  4032ee:	48 8d 04 80          	lea    (%rax,%rax,4),%rax

float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
	float t3 = t2*t;
	float h1 = 2*t3 - 3*t2 + 1;
  4032f2:	f3 0f 58 cb          	addss  %xmm3,%xmm1
	float h2 = -2*t3 + 3*t2;             
	float h3 = t3 - 2 * t2 + t;        
	float h4 = t3 - t2;              
  4032f6:	f3 0f 5c da          	subss  %xmm2,%xmm3
	{
#ifdef PRINT
		cout << "hermite ";
		cout << hermite(t, m_p1, m_p2, m_n1, m_n2);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = hermite(t, m_p1, m_p2, m_n1, m_n2);
  4032fa:	48 c1 e0 02          	shl    $0x2,%rax
float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
	float t3 = t2*t;
	float h1 = 2*t3 - 3*t2 + 1;
	float h2 = -2*t3 + 3*t2;             
  4032fe:	f3 0f 58 e5          	addss  %xmm5,%xmm4
	{
#ifdef PRINT
		cout << "hermite ";
		cout << hermite(t, m_p1, m_p2, m_n1, m_n2);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = hermite(t, m_p1, m_p2, m_n1, m_n2);
  403302:	48 29 c6             	sub    %rax,%rsi

float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
	float t3 = t2*t;
	float h1 = 2*t3 - 3*t2 + 1;
  403305:	f3 0f 5c cd          	subss  %xmm5,%xmm1
	float h2 = -2*t3 + 3*t2;             
	float h3 = t3 - 2 * t2 + t;        
	float h4 = t3 - t2;              
	return h1*p1 + h2*p2 + h3*n1 + h4*n2;
  403309:	f3 0f 59 5f 1c       	mulss  0x1c(%rdi),%xmm3
  40330e:	f3 0f 59 67 14       	mulss  0x14(%rdi),%xmm4

float hermite(float t, float p1, float p2, float n1, float n2)
{
	float t2 = t*t*t;
	float t3 = t2*t;
	float h1 = 2*t3 - 3*t2 + 1;
  403313:	f3 0f 58 0d 01 25 00 	addss  0x2501(%rip),%xmm1        # 40581c <_ZN14entity_hermite4typeE+0xc>
  40331a:	00 
	float h2 = -2*t3 + 3*t2;             
	float h3 = t3 - 2 * t2 + t;        
	float h4 = t3 - t2;              
	return h1*p1 + h2*p2 + h3*n1 + h4*n2;
  40331b:	f3 0f 59 4f 10       	mulss  0x10(%rdi),%xmm1
  403320:	f3 0f 58 cc          	addss  %xmm4,%xmm1
{
	float t2 = t*t*t;
	float t3 = t2*t;
	float h1 = 2*t3 - 3*t2 + 1;
	float h2 = -2*t3 + 3*t2;             
	float h3 = t3 - 2 * t2 + t;        
  403324:	0f 28 e2             	movaps %xmm2,%xmm4
  403327:	f3 0f 58 e2          	addss  %xmm2,%xmm4
  40332b:	f3 0f 5c f4          	subss  %xmm4,%xmm6
  40332f:	0f 28 e6             	movaps %xmm6,%xmm4
  403332:	f3 0f 58 e0          	addss  %xmm0,%xmm4
	float h4 = t3 - t2;              
	return h1*p1 + h2*p2 + h3*n1 + h4*n2;
  403336:	f3 0f 59 67 18       	mulss  0x18(%rdi),%xmm4
  40333b:	f3 0f 58 cc          	addss  %xmm4,%xmm1
  40333f:	f3 0f 58 cb          	addss  %xmm3,%xmm1
	{
#ifdef PRINT
		cout << "hermite ";
		cout << hermite(t, m_p1, m_p2, m_n1, m_n2);
#endif
		dummyOut[dummyOutIndex % ARRAY_SIZE(dummyOut)] = hermite(t, m_p1, m_p2, m_n1, m_n2);
  403343:	f3 0f 11 0c b5 40 73 	movss  %xmm1,0x607340(,%rsi,4)
  40334a:	60 00 
		dummyOutIndex++;
  40334c:	c3                   	retq   
  40334d:	0f 1f 00             	nopl   (%rax)

0000000000403350 <_Z17SlowUpdateExamplev>:
	}
};


void SlowUpdateExample()
{
  403350:	41 55                	push   %r13
	pointer _M_start;
	pointer _M_finish;
	pointer _M_end_of_storage;

	_Vector_impl()
	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
  403352:	31 c0                	xor    %eax,%eax
  403354:	31 f6                	xor    %esi,%esi
  403356:	41 54                	push   %r12
  403358:	55                   	push   %rbp
  403359:	53                   	push   %rbx
  40335a:	bb 90 01 00 00       	mov    $0x190,%ebx
  40335f:	48 83 ec 78          	sub    $0x78,%rsp

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  403363:	48 8b 2d 96 23 00 00 	mov    0x2396(%rip),%rbp        # 405700 <_ZN16entity_lerp_slow4typeE>
    {
      if ((__detail::__mod<_UIntType, __m>(__c) == 0)
	  && (__detail::__mod<_UIntType, __m>(__s) == 0))
	_M_x = 1;
      else
	_M_x = __detail::__mod<_UIntType, __m>(__s);
  40336a:	48 c7 44 24 10 01 00 	movq   $0x1,0x10(%rsp)
  403371:	00 00 
  403373:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
  40337a:	00 00 
  40337c:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
  403383:	00 00 
  403385:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
  40338c:	00 00 
  40338e:	eb 16                	jmp    4033a6 <_Z17SlowUpdateExamplev+0x56>
  403390:	48 85 f6             	test   %rsi,%rsi
  403393:	74 03                	je     403398 <_Z17SlowUpdateExamplev+0x48>
  403395:	48 89 2e             	mov    %rbp,(%rsi)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  403398:	48 83 c6 08          	add    $0x8,%rsi
	uniform_real_distribution<float> distribution(0, 1);

	int number_of_lerp = 400;
	int number_of_hermite = 1000;
	vector<long long> create_types;
	for (int i = 0; i < number_of_lerp; i++)
  40339c:	83 eb 01             	sub    $0x1,%ebx
  40339f:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
  4033a4:	74 23                	je     4033c9 <_Z17SlowUpdateExamplev+0x79>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  4033a6:	48 39 c6             	cmp    %rax,%rsi
  4033a9:	75 e5                	jne    403390 <_Z17SlowUpdateExamplev+0x40>
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  4033ab:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  4033b0:	be 00 57 40 00       	mov    $0x405700,%esi
  4033b5:	e8 46 18 00 00       	callq  404c00 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_>
  4033ba:	83 eb 01             	sub    $0x1,%ebx
  4033bd:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  4033c2:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  4033c7:	75 dd                	jne    4033a6 <_Z17SlowUpdateExamplev+0x56>
  4033c9:	bb e8 03 00 00       	mov    $0x3e8,%ebx
  4033ce:	48 8b 2d 3b 24 00 00 	mov    0x243b(%rip),%rbp        # 405810 <_ZN14entity_hermite4typeE>
  4033d5:	eb 24                	jmp    4033fb <_Z17SlowUpdateExamplev+0xab>
  4033d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4033de:	00 00 
  4033e0:	48 85 f6             	test   %rsi,%rsi
  4033e3:	74 03                	je     4033e8 <_Z17SlowUpdateExamplev+0x98>
  4033e5:	48 89 2e             	mov    %rbp,(%rsi)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  4033e8:	48 83 c6 08          	add    $0x8,%rsi
	{
		create_types.emplace_back(entity_lerp_slow::type);
	}
	for (int i = 0; i < number_of_hermite; i++)
  4033ec:	83 eb 01             	sub    $0x1,%ebx
  4033ef:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
  4033f4:	74 23                	je     403419 <_Z17SlowUpdateExamplev+0xc9>
  4033f6:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  4033fb:	48 39 c6             	cmp    %rax,%rsi
  4033fe:	75 e0                	jne    4033e0 <_Z17SlowUpdateExamplev+0x90>
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  403400:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  403405:	be 10 58 40 00       	mov    $0x405810,%esi
  40340a:	e8 f1 17 00 00       	callq  404c00 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_>
  40340f:	83 eb 01             	sub    $0x1,%ebx
  403412:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  403417:	75 dd                	jne    4033f6 <_Z17SlowUpdateExamplev+0xa6>
	{
		create_types.emplace_back(entity_hermite::type);
	}

	shuffle(create_types.begin(), create_types.end(), generator);
  403419:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
  40341e:	48 8d 54 24 10       	lea    0x10(%rsp),%rdx
  403423:	e8 b8 1b 00 00       	callq  404fe0 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_>
      typedef typename __traits_type::pointer   	pointer;

      _GLIBCXX_CONSTEXPR __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
  403428:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
  40342d:	4c 8b 64 24 38       	mov    0x38(%rsp),%r12
  403432:	48 c7 44 24 50 00 00 	movq   $0x0,0x50(%rsp)
  403439:	00 00 
  40343b:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
  403442:	00 00 
  403444:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
  40344b:	00 00 

	vector<unique_ptr<entity>> entity_vec;
	for (auto &create_type : create_types)
  40344d:	4c 39 e3             	cmp    %r12,%rbx
  403450:	0f 84 81 03 00 00    	je     4037d7 <_Z17SlowUpdateExamplev+0x487>
  403456:	0f 57 db             	xorps  %xmm3,%xmm3
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
	  if (__m)
	    __res %= __m;
  403459:	48 bd 05 00 00 00 02 	movabs $0x200000005,%rbp
  403460:	00 00 00 
  403463:	f3 0f 11 5c 24 0c    	movss  %xmm3,0xc(%rsp)
  403469:	e9 06 01 00 00       	jmpq   403574 <_Z17SlowUpdateExamplev+0x224>
  40346e:	66 90                	xchg   %ax,%ax
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  403470:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  403475:	48 69 f0 a7 41 00 00 	imul   $0x41a7,%rax,%rsi
	  if (__m)
	    __res %= __m;
  40347c:	48 89 f0             	mov    %rsi,%rax
  40347f:	48 f7 e5             	mul    %rbp
  403482:	48 89 f0             	mov    %rsi,%rax
  403485:	48 29 d0             	sub    %rdx,%rax
  403488:	48 d1 e8             	shr    %rax
  40348b:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  40348f:	48 c1 e9 1e          	shr    $0x1e,%rcx
  403493:	48 89 c8             	mov    %rcx,%rax
  403496:	48 c1 e0 1f          	shl    $0x1f,%rax
  40349a:	48 29 c8             	sub    %rcx,%rax
  40349d:	48 89 f1             	mov    %rsi,%rcx
  4034a0:	48 29 c1             	sub    %rax,%rcx
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  4034a3:	48 69 f1 a7 41 00 00 	imul   $0x41a7,%rcx,%rsi
	  if (__m)
	    __res %= __m;
  4034aa:	48 89 f0             	mov    %rsi,%rax
  4034ad:	48 f7 e5             	mul    %rbp
  4034b0:	48 89 f0             	mov    %rsi,%rax
  4034b3:	48 29 d0             	sub    %rdx,%rax
  4034b6:	48 d1 e8             	shr    %rax
  4034b9:	48 01 c2             	add    %rax,%rdx
  4034bc:	48 c1 ea 1e          	shr    $0x1e,%rdx
  4034c0:	48 89 d0             	mov    %rdx,%rax
  4034c3:	48 c1 e0 1f          	shl    $0x1f,%rax
  4034c7:	48 29 d0             	sub    %rdx,%rax
  4034ca:	48 89 f2             	mov    %rsi,%rdx
  4034cd:	48 29 c2             	sub    %rax,%rdx
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  4034d0:	48 83 e9 01          	sub    $0x1,%rcx
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  4034d4:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  4034d9:	0f 88 51 02 00 00    	js     403730 <_Z17SlowUpdateExamplev+0x3e0>
  4034df:	f3 48 0f 2a c9       	cvtsi2ss %rcx,%xmm1
  4034e4:	f3 0f 10 64 24 0c    	movss  0xc(%rsp),%xmm4
  4034ea:	48 83 ea 01          	sub    $0x1,%rdx
  4034ee:	f3 0f 58 cc          	addss  %xmm4,%xmm1
	  __tmp *= __r;
	}
      return __sum / __tmp;
  4034f2:	f3 0f 59 0d d2 23 00 	mulss  0x23d2(%rip),%xmm1        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  4034f9:	00 
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{
	  __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
	    __aurng(__urng);
	  return (__aurng() * (__p.b() - __p.a())) + __p.a();
  4034fa:	f3 0f 58 cc          	addss  %xmm4,%xmm1
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  4034fe:	0f 88 0c 02 00 00    	js     403710 <_Z17SlowUpdateExamplev+0x3c0>
  403504:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  403509:	f3 0f 10 6c 24 0c    	movss  0xc(%rsp),%xmm5
  40350f:	f3 0f 58 c5          	addss  %xmm5,%xmm0
	  __tmp *= __r;
	}
      return __sum / __tmp;
  403513:	f3 0f 59 05 b1 23 00 	mulss  0x23b1(%rip),%xmm0        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  40351a:	00 
  40351b:	f3 0f 58 c5          	addss  %xmm5,%xmm0
			unique_ptr<entity> a(create_entity_hermite(distribution(generator), distribution(generator), distribution(generator), distribution(generator)));
			entity_vec.emplace_back(std::move(a));
		}
		else
		{
			unique_ptr<entity> a(create_entity_lerp_slow(distribution(generator), distribution(generator)));
  40351f:	e8 dc f8 ff ff       	callq  402e00 <_Z23create_entity_lerp_slowff>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  403524:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  403529:	48 3b 54 24 60       	cmp    0x60(%rsp),%rdx
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
  40352e:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  403533:	0f 84 87 02 00 00    	je     4037c0 <_Z17SlowUpdateExamplev+0x470>
  403539:	48 85 d2             	test   %rdx,%rdx
  40353c:	0f 84 0e 02 00 00    	je     403750 <_Z17SlowUpdateExamplev+0x400>
      // Modifiers.
      pointer
      release() noexcept
      {
	pointer __p = get();
	std::get<0>(_M_t) = pointer();
  403542:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
  403549:	00 00 
  40354b:	48 89 02             	mov    %rax,(%rdx)
  40354e:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  403553:	48 83 c2 08          	add    $0x8,%rdx
  403557:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  40355c:	48 85 ff             	test   %rdi,%rdi
  40355f:	74 06                	je     403567 <_Z17SlowUpdateExamplev+0x217>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  403561:	48 8b 07             	mov    (%rdi),%rax
  403564:	ff 50 18             	callq  *0x18(%rax)
  403567:	48 83 c3 08          	add    $0x8,%rbx
	}

	shuffle(create_types.begin(), create_types.end(), generator);

	vector<unique_ptr<entity>> entity_vec;
	for (auto &create_type : create_types)
  40356b:	49 39 dc             	cmp    %rbx,%r12
  40356e:	0f 84 6c 02 00 00    	je     4037e0 <_Z17SlowUpdateExamplev+0x490>
	{
		if (create_type == entity_hermite::type)
  403574:	48 8b 05 95 22 00 00 	mov    0x2295(%rip),%rax        # 405810 <_ZN14entity_hermite4typeE>
  40357b:	48 39 03             	cmp    %rax,(%rbx)
  40357e:	0f 85 ec fe ff ff    	jne    403470 <_Z17SlowUpdateExamplev+0x120>
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  403584:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  403589:	48 69 ca a7 41 00 00 	imul   $0x41a7,%rdx,%rcx
	  if (__m)
	    __res %= __m;
  403590:	48 89 c8             	mov    %rcx,%rax
  403593:	48 f7 e5             	mul    %rbp
  403596:	48 89 c8             	mov    %rcx,%rax
  403599:	48 29 d0             	sub    %rdx,%rax
  40359c:	48 d1 e8             	shr    %rax
  40359f:	48 8d 3c 02          	lea    (%rdx,%rax,1),%rdi
  4035a3:	48 c1 ef 1e          	shr    $0x1e,%rdi
  4035a7:	48 89 f8             	mov    %rdi,%rax
  4035aa:	48 c1 e0 1f          	shl    $0x1f,%rax
  4035ae:	48 29 f8             	sub    %rdi,%rax
  4035b1:	48 29 c1             	sub    %rax,%rcx
  4035b4:	48 89 cf             	mov    %rcx,%rdi
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  4035b7:	48 69 c9 a7 41 00 00 	imul   $0x41a7,%rcx,%rcx
	  if (__m)
	    __res %= __m;
  4035be:	48 89 c8             	mov    %rcx,%rax
  4035c1:	48 f7 e5             	mul    %rbp
  4035c4:	48 89 c8             	mov    %rcx,%rax
  4035c7:	48 29 d0             	sub    %rdx,%rax
  4035ca:	48 d1 e8             	shr    %rax
  4035cd:	48 8d 34 02          	lea    (%rdx,%rax,1),%rsi
  4035d1:	48 c1 ee 1e          	shr    $0x1e,%rsi
  4035d5:	48 89 f0             	mov    %rsi,%rax
  4035d8:	48 c1 e0 1f          	shl    $0x1f,%rax
  4035dc:	48 29 f0             	sub    %rsi,%rax
  4035df:	48 29 c1             	sub    %rax,%rcx
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  4035e2:	4c 69 c1 a7 41 00 00 	imul   $0x41a7,%rcx,%r8
	  if (__m)
	    __res %= __m;
  4035e9:	48 89 ce             	mov    %rcx,%rsi
  4035ec:	4c 89 c0             	mov    %r8,%rax
  4035ef:	48 f7 e5             	mul    %rbp
  4035f2:	4c 89 c0             	mov    %r8,%rax
  4035f5:	48 29 d0             	sub    %rdx,%rax
  4035f8:	48 d1 e8             	shr    %rax
  4035fb:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  4035ff:	48 c1 e9 1e          	shr    $0x1e,%rcx
  403603:	48 89 c8             	mov    %rcx,%rax
  403606:	48 c1 e0 1f          	shl    $0x1f,%rax
  40360a:	48 29 c8             	sub    %rcx,%rax
  40360d:	4c 89 c1             	mov    %r8,%rcx
  403610:	48 29 c1             	sub    %rax,%rcx
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  403613:	4c 69 c1 a7 41 00 00 	imul   $0x41a7,%rcx,%r8
	  if (__m)
	    __res %= __m;
  40361a:	4c 89 c0             	mov    %r8,%rax
  40361d:	48 f7 e5             	mul    %rbp
  403620:	4c 89 c0             	mov    %r8,%rax
  403623:	48 29 d0             	sub    %rdx,%rax
  403626:	48 d1 e8             	shr    %rax
  403629:	48 01 c2             	add    %rax,%rdx
  40362c:	48 c1 ea 1e          	shr    $0x1e,%rdx
  403630:	48 89 d0             	mov    %rdx,%rax
  403633:	48 c1 e0 1f          	shl    $0x1f,%rax
  403637:	48 29 d0             	sub    %rdx,%rax
  40363a:	4c 89 c2             	mov    %r8,%rdx
  40363d:	48 29 c2             	sub    %rax,%rdx
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  403640:	48 83 ef 01          	sub    $0x1,%rdi
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  403644:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  403649:	0f 88 23 01 00 00    	js     403772 <_Z17SlowUpdateExamplev+0x422>
  40364f:	f3 48 0f 2a df       	cvtsi2ss %rdi,%xmm3
  403654:	f3 0f 10 7c 24 0c    	movss  0xc(%rsp),%xmm7
  40365a:	48 83 ee 01          	sub    $0x1,%rsi
  40365e:	f3 0f 58 df          	addss  %xmm7,%xmm3
	  __tmp *= __r;
	}
      return __sum / __tmp;
  403662:	f3 0f 59 1d 62 22 00 	mulss  0x2262(%rip),%xmm3        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  403669:	00 
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{
	  __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
	    __aurng(__urng);
	  return (__aurng() * (__p.b() - __p.a())) + __p.a();
  40366a:	f3 0f 58 df          	addss  %xmm7,%xmm3
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  40366e:	0f 88 32 01 00 00    	js     4037a6 <_Z17SlowUpdateExamplev+0x456>
  403674:	f3 48 0f 2a d6       	cvtsi2ss %rsi,%xmm2
  403679:	f3 0f 10 7c 24 0c    	movss  0xc(%rsp),%xmm7
  40367f:	48 83 e9 01          	sub    $0x1,%rcx
  403683:	f3 0f 58 d7          	addss  %xmm7,%xmm2
	  __tmp *= __r;
	}
      return __sum / __tmp;
  403687:	f3 0f 59 15 3d 22 00 	mulss  0x223d(%rip),%xmm2        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  40368e:	00 
  40368f:	f3 0f 58 d7          	addss  %xmm7,%xmm2
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  403693:	0f 88 f3 00 00 00    	js     40378c <_Z17SlowUpdateExamplev+0x43c>
  403699:	f3 48 0f 2a c9       	cvtsi2ss %rcx,%xmm1
  40369e:	f3 0f 10 74 24 0c    	movss  0xc(%rsp),%xmm6
  4036a4:	48 83 ea 01          	sub    $0x1,%rdx
  4036a8:	f3 0f 58 ce          	addss  %xmm6,%xmm1
	  __tmp *= __r;
	}
      return __sum / __tmp;
  4036ac:	f3 0f 59 0d 18 22 00 	mulss  0x2218(%rip),%xmm1        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  4036b3:	00 
  4036b4:	f3 0f 58 ce          	addss  %xmm6,%xmm1
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  4036b8:	0f 88 9a 00 00 00    	js     403758 <_Z17SlowUpdateExamplev+0x408>
  4036be:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  4036c3:	f3 0f 10 7c 24 0c    	movss  0xc(%rsp),%xmm7
  4036c9:	f3 0f 58 c7          	addss  %xmm7,%xmm0
	  __tmp *= __r;
	}
      return __sum / __tmp;
  4036cd:	f3 0f 59 05 f7 21 00 	mulss  0x21f7(%rip),%xmm0        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  4036d4:	00 
  4036d5:	f3 0f 58 c7          	addss  %xmm7,%xmm0
		{
			unique_ptr<entity> a(create_entity_hermite(distribution(generator), distribution(generator), distribution(generator), distribution(generator)));
  4036d9:	e8 f2 fa ff ff       	callq  4031d0 <_Z21create_entity_hermiteffff>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  4036de:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  4036e3:	48 3b 54 24 60       	cmp    0x60(%rsp),%rdx
  4036e8:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  4036ed:	0f 85 46 fe ff ff    	jne    403539 <_Z17SlowUpdateExamplev+0x1e9>
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  4036f3:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  4036f8:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  4036fd:	4c 89 ef             	mov    %r13,%rdi
  403700:	e8 bb 1a 00 00       	callq  4051c0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_>
  403705:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  40370a:	e9 4d fe ff ff       	jmpq   40355c <_Z17SlowUpdateExamplev+0x20c>
  40370f:	90                   	nop
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  403710:	48 89 d0             	mov    %rdx,%rax
  403713:	83 e2 01             	and    $0x1,%edx
  403716:	48 d1 e8             	shr    %rax
  403719:	48 09 d0             	or     %rdx,%rax
  40371c:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  403721:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  403725:	e9 df fd ff ff       	jmpq   403509 <_Z17SlowUpdateExamplev+0x1b9>
  40372a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  403730:	48 89 c8             	mov    %rcx,%rax
  403733:	83 e1 01             	and    $0x1,%ecx
  403736:	48 d1 e8             	shr    %rax
  403739:	48 09 c8             	or     %rcx,%rax
  40373c:	f3 48 0f 2a c8       	cvtsi2ss %rax,%xmm1
  403741:	f3 0f 58 c9          	addss  %xmm1,%xmm1
  403745:	e9 9a fd ff ff       	jmpq   4034e4 <_Z17SlowUpdateExamplev+0x194>
  40374a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  403750:	48 89 c7             	mov    %rax,%rdi
  403753:	e9 fb fd ff ff       	jmpq   403553 <_Z17SlowUpdateExamplev+0x203>
  403758:	48 89 d0             	mov    %rdx,%rax
  40375b:	83 e2 01             	and    $0x1,%edx
  40375e:	48 d1 e8             	shr    %rax
  403761:	48 09 d0             	or     %rdx,%rax
  403764:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  403769:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  40376d:	e9 51 ff ff ff       	jmpq   4036c3 <_Z17SlowUpdateExamplev+0x373>
  403772:	48 89 f8             	mov    %rdi,%rax
  403775:	83 e7 01             	and    $0x1,%edi
  403778:	48 d1 e8             	shr    %rax
  40377b:	48 09 f8             	or     %rdi,%rax
  40377e:	f3 48 0f 2a d8       	cvtsi2ss %rax,%xmm3
  403783:	f3 0f 58 db          	addss  %xmm3,%xmm3
  403787:	e9 c8 fe ff ff       	jmpq   403654 <_Z17SlowUpdateExamplev+0x304>
  40378c:	48 89 c8             	mov    %rcx,%rax
  40378f:	83 e1 01             	and    $0x1,%ecx
  403792:	48 d1 e8             	shr    %rax
  403795:	48 09 c8             	or     %rcx,%rax
  403798:	f3 48 0f 2a c8       	cvtsi2ss %rax,%xmm1
  40379d:	f3 0f 58 c9          	addss  %xmm1,%xmm1
  4037a1:	e9 f8 fe ff ff       	jmpq   40369e <_Z17SlowUpdateExamplev+0x34e>
  4037a6:	48 89 f0             	mov    %rsi,%rax
  4037a9:	83 e6 01             	and    $0x1,%esi
  4037ac:	48 d1 e8             	shr    %rax
  4037af:	48 09 f0             	or     %rsi,%rax
  4037b2:	f3 48 0f 2a d0       	cvtsi2ss %rax,%xmm2
  4037b7:	f3 0f 58 d2          	addss  %xmm2,%xmm2
  4037bb:	e9 b9 fe ff ff       	jmpq   403679 <_Z17SlowUpdateExamplev+0x329>
  4037c0:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  4037c5:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  4037ca:	4c 89 ef             	mov    %r13,%rdi
  4037cd:	e8 ee 19 00 00       	callq  4051c0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_>
  4037d2:	e9 2e ff ff ff       	jmpq   403705 <_Z17SlowUpdateExamplev+0x3b5>
  4037d7:	0f 57 d2             	xorps  %xmm2,%xmm2
  4037da:	f3 0f 11 54 24 0c    	movss  %xmm2,0xc(%rsp)
public:
	std::chrono::time_point<std::chrono::high_resolution_clock> m_start;
	std::chrono::time_point<std::chrono::high_resolution_clock> m_end;
	mytimer()
	{
		m_start = std::chrono::high_resolution_clock::now();
  4037e0:	e8 ab ed ff ff       	callq  402590 <_ZNSt6chrono3_V212system_clock3nowEv@plt>
  4037e5:	41 bc 14 00 00 00    	mov    $0x14,%r12d
  4037eb:	49 89 c5             	mov    %rax,%r13
  4037ee:	66 90                	xchg   %ax,%ax
  4037f0:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
  4037f5:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx

	{
		// change styles for document 
		mytimer timer;
		for (float t = 0.0f; t < 1.0; t += 0.05f) {
			for (auto &a : entity_vec) {
  4037fa:	48 39 eb             	cmp    %rbp,%rbx
  4037fd:	74 18                	je     403817 <_Z17SlowUpdateExamplev+0x4c7>
  4037ff:	90                   	nop
	return get();
      }

      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
  403800:	48 8b 3b             	mov    (%rbx),%rdi
				// slow version each object has a virtual update.
				a->Update(t);
  403803:	f3 0f 10 44 24 0c    	movss  0xc(%rsp),%xmm0
  403809:	48 8b 17             	mov    (%rdi),%rdx
  40380c:	ff 12                	callq  *(%rdx)
  40380e:	48 83 c3 08          	add    $0x8,%rbx

	{
		// change styles for document 
		mytimer timer;
		for (float t = 0.0f; t < 1.0; t += 0.05f) {
			for (auto &a : entity_vec) {
  403812:	48 39 dd             	cmp    %rbx,%rbp
  403815:	75 e9                	jne    403800 <_Z17SlowUpdateExamplev+0x4b0>
	}

	{
		// change styles for document 
		mytimer timer;
		for (float t = 0.0f; t < 1.0; t += 0.05f) {
  403817:	f3 0f 10 35 a9 20 00 	movss  0x20a9(%rip),%xmm6        # 4058c8 <_ZN14entity_hermite4typeE+0xb8>
  40381e:	00 
  40381f:	41 83 ec 01          	sub    $0x1,%r12d
  403823:	f3 0f 58 74 24 0c    	addss  0xc(%rsp),%xmm6
  403829:	f3 0f 11 74 24 0c    	movss  %xmm6,0xc(%rsp)
  40382f:	75 bf                	jne    4037f0 <_Z17SlowUpdateExamplev+0x4a0>
	{
		m_start = std::chrono::high_resolution_clock::now();
	}
	std::chrono::duration<double> stop()
	{
		m_end = std::chrono::high_resolution_clock::now();
  403831:	e8 5a ed ff ff       	callq  402590 <_ZNSt6chrono3_V212system_clock3nowEv@plt>
		const duration<_Rep2, _Period2>& __rhs)
      {
	typedef duration<_Rep1, _Period1>			__dur1;
	typedef duration<_Rep2, _Period2>			__dur2;
	typedef typename common_type<__dur1,__dur2>::type	__cd;
	return __cd(__cd(__lhs).count() - __cd(__rhs).count());
  403836:	4c 29 e8             	sub    %r13,%rax
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(
	      static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));
  403839:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  40383e:	48 8b 05 e3 3a 20 00 	mov    0x203ae3(%rip),%rax        # 607328 <gSlowSimpleUpdateExampleTimers+0x8>
  403845:	48 3b 05 e4 3a 20 00 	cmp    0x203ae4(%rip),%rax        # 607330 <gSlowSimpleUpdateExampleTimers+0x10>
  40384c:	f2 0f 5e 05 6c 20 00 	divsd  0x206c(%rip),%xmm0        # 4058c0 <_ZN14entity_hermite4typeE+0xb0>
  403853:	00 
			for (auto &a : entity_vec) {
				// slow version each object has a virtual update.
				a->Update(t);
			}
		}
		gSlowSimpleUpdateExampleTimers.emplace_back(timer.stop());
  403854:	f2 0f 11 44 24 20    	movsd  %xmm0,0x20(%rsp)
  40385a:	74 7b                	je     4038d7 <_Z17SlowUpdateExamplev+0x587>
  40385c:	48 85 c0             	test   %rax,%rax
  40385f:	74 0c                	je     40386d <_Z17SlowUpdateExamplev+0x51d>
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(
	      static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));
  403861:	f2 0f 59 05 4f 20 00 	mulsd  0x204f(%rip),%xmm0        # 4058b8 <_ZN14entity_hermite4typeE+0xa8>
  403868:	00 
	template<typename _Rep2, typename _Period2, typename = typename
	       enable_if<treat_as_floating_point<rep>::value
			 || (ratio_divide<_Period2, period>::den == 1
			     && !treat_as_floating_point<_Rep2>::value)>::type>
	  constexpr duration(const duration<_Rep2, _Period2>& __d)
	  : __r(duration_cast<duration>(__d).count()) { }
  403869:	f2 0f 11 00          	movsd  %xmm0,(%rax)
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }
  40386d:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
  403872:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  403877:	48 83 c0 08          	add    $0x8,%rax
  40387b:	48 89 05 a6 3a 20 00 	mov    %rax,0x203aa6(%rip)        # 607328 <gSlowSimpleUpdateExampleTimers+0x8>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
	{
	  for (; __first != __last; ++__first)
  403882:	48 39 dd             	cmp    %rbx,%rbp
  403885:	74 6e                	je     4038f5 <_Z17SlowUpdateExamplev+0x5a5>
  403887:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40388e:	00 00 

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  403890:	48 8b 3b             	mov    (%rbx),%rdi
  403893:	48 85 ff             	test   %rdi,%rdi
  403896:	74 06                	je     40389e <_Z17SlowUpdateExamplev+0x54e>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  403898:	48 8b 07             	mov    (%rdi),%rax
  40389b:	ff 50 18             	callq  *0x18(%rax)
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
	  get_deleter()(__ptr);
	__ptr = pointer();
  40389e:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
  4038a5:	48 83 c3 08          	add    $0x8,%rbx
  4038a9:	48 39 dd             	cmp    %rbx,%rbp
  4038ac:	75 e2                	jne    403890 <_Z17SlowUpdateExamplev+0x540>
  4038ae:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  4038b3:	48 85 ff             	test   %rdi,%rdi
  4038b6:	74 05                	je     4038bd <_Z17SlowUpdateExamplev+0x56d>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  4038b8:	e8 93 ec ff ff       	callq  402550 <_ZdlPv@plt>
      }
#endif

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  4038bd:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  4038c2:	48 85 ff             	test   %rdi,%rdi
  4038c5:	74 05                	je     4038cc <_Z17SlowUpdateExamplev+0x57c>
  4038c7:	e8 84 ec ff ff       	callq  402550 <_ZdlPv@plt>
	}
}
  4038cc:	48 83 c4 78          	add    $0x78,%rsp
  4038d0:	5b                   	pop    %rbx
  4038d1:	5d                   	pop    %rbp
  4038d2:	41 5c                	pop    %r12
  4038d4:	41 5d                	pop    %r13
  4038d6:	c3                   	retq   
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  4038d7:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  4038dc:	bf 20 73 60 00       	mov    $0x607320,%edi
  4038e1:	e8 3a 1a 00 00       	callq  405320 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EE19_M_emplace_back_auxIINS1_IdS2_ILl1ELl1EEEEEEEvDpOT_>
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }
  4038e6:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
  4038eb:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
  4038f0:	48 39 dd             	cmp    %rbx,%rbp
  4038f3:	75 9b                	jne    403890 <_Z17SlowUpdateExamplev+0x540>
  4038f5:	48 89 ef             	mov    %rbp,%rdi
  4038f8:	eb b9                	jmp    4038b3 <_Z17SlowUpdateExamplev+0x563>
  4038fa:	48 89 c3             	mov    %rax,%rbx
      }
#endif

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  4038fd:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  403902:	48 85 ff             	test   %rdi,%rdi
  403905:	74 05                	je     40390c <_Z17SlowUpdateExamplev+0x5bc>
  403907:	e8 44 ec ff ff       	callq  402550 <_ZdlPv@plt>
  40390c:	48 89 df             	mov    %rbx,%rdi
  40390f:	e8 1c ed ff ff       	callq  402630 <_Unwind_Resume@plt>

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  403914:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  403919:	48 89 c3             	mov    %rax,%rbx
  40391c:	48 85 ff             	test   %rdi,%rdi
  40391f:	74 06                	je     403927 <_Z17SlowUpdateExamplev+0x5d7>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  403921:	48 8b 07             	mov    (%rdi),%rax
  403924:	ff 50 18             	callq  *0x18(%rax)
		create_types.emplace_back(entity_hermite::type);
	}

	shuffle(create_types.begin(), create_types.end(), generator);

	vector<unique_ptr<entity>> entity_vec;
  403927:	4c 89 ef             	mov    %r13,%rdi
  40392a:	e8 71 12 00 00       	callq  404ba0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EED1Ev>
  40392f:	eb cc                	jmp    4038fd <_Z17SlowUpdateExamplev+0x5ad>
  403931:	eb e1                	jmp    403914 <_Z17SlowUpdateExamplev+0x5c4>
  403933:	48 89 c3             	mov    %rax,%rbx
  403936:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  40393b:	eb ea                	jmp    403927 <_Z17SlowUpdateExamplev+0x5d7>
  40393d:	0f 1f 00             	nopl   (%rax)

0000000000403940 <_Z32MethodPointerUpdateExampleTimersv>:
class entity;
typedef  void(*as_normfun)(entity *_this, float y);		

#ifdef __GNUC__
void MethodPointerUpdateExampleTimers()
{
  403940:	41 55                	push   %r13
	pointer _M_start;
	pointer _M_finish;
	pointer _M_end_of_storage;

	_Vector_impl()
	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
  403942:	31 c0                	xor    %eax,%eax
  403944:	31 f6                	xor    %esi,%esi
  403946:	41 54                	push   %r12
  403948:	55                   	push   %rbp
  403949:	53                   	push   %rbx
  40394a:	bb 90 01 00 00       	mov    $0x190,%ebx
  40394f:	48 83 ec 78          	sub    $0x78,%rsp

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  403953:	48 8b 2d 9e 1d 00 00 	mov    0x1d9e(%rip),%rbp        # 4056f8 <_ZN16entity_lerp_fast4typeE>
    {
      if ((__detail::__mod<_UIntType, __m>(__c) == 0)
	  && (__detail::__mod<_UIntType, __m>(__s) == 0))
	_M_x = 1;
      else
	_M_x = __detail::__mod<_UIntType, __m>(__s);
  40395a:	48 c7 44 24 10 01 00 	movq   $0x1,0x10(%rsp)
  403961:	00 00 
  403963:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
  40396a:	00 00 
  40396c:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
  403973:	00 00 
  403975:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
  40397c:	00 00 
  40397e:	eb 16                	jmp    403996 <_Z32MethodPointerUpdateExampleTimersv+0x56>
  403980:	48 85 f6             	test   %rsi,%rsi
  403983:	74 03                	je     403988 <_Z32MethodPointerUpdateExampleTimersv+0x48>
  403985:	48 89 2e             	mov    %rbp,(%rsi)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  403988:	48 83 c6 08          	add    $0x8,%rsi
	uniform_real_distribution<float> distribution(0, 1);

	int number_of_lerp = 400;
	int number_of_hermite = 1000;
	vector<long long> create_types;
	for (int i = 0; i < number_of_lerp; i++)
  40398c:	83 eb 01             	sub    $0x1,%ebx
  40398f:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
  403994:	74 23                	je     4039b9 <_Z32MethodPointerUpdateExampleTimersv+0x79>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  403996:	48 39 c6             	cmp    %rax,%rsi
  403999:	75 e5                	jne    403980 <_Z32MethodPointerUpdateExampleTimersv+0x40>
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  40399b:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  4039a0:	be f8 56 40 00       	mov    $0x4056f8,%esi
  4039a5:	e8 56 12 00 00       	callq  404c00 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_>
  4039aa:	83 eb 01             	sub    $0x1,%ebx
  4039ad:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  4039b2:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  4039b7:	75 dd                	jne    403996 <_Z32MethodPointerUpdateExampleTimersv+0x56>
  4039b9:	bb e8 03 00 00       	mov    $0x3e8,%ebx
  4039be:	48 8b 2d 4b 1e 00 00 	mov    0x1e4b(%rip),%rbp        # 405810 <_ZN14entity_hermite4typeE>
  4039c5:	eb 24                	jmp    4039eb <_Z32MethodPointerUpdateExampleTimersv+0xab>
  4039c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4039ce:	00 00 
  4039d0:	48 85 f6             	test   %rsi,%rsi
  4039d3:	74 03                	je     4039d8 <_Z32MethodPointerUpdateExampleTimersv+0x98>
  4039d5:	48 89 2e             	mov    %rbp,(%rsi)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  4039d8:	48 83 c6 08          	add    $0x8,%rsi
	{
		create_types.emplace_back(entity_lerp_fast::type);
	}
	for (int i = 0; i < number_of_hermite; i++)
  4039dc:	83 eb 01             	sub    $0x1,%ebx
  4039df:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
  4039e4:	74 23                	je     403a09 <_Z32MethodPointerUpdateExampleTimersv+0xc9>
  4039e6:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  4039eb:	48 39 c6             	cmp    %rax,%rsi
  4039ee:	75 e0                	jne    4039d0 <_Z32MethodPointerUpdateExampleTimersv+0x90>
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  4039f0:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  4039f5:	be 10 58 40 00       	mov    $0x405810,%esi
  4039fa:	e8 01 12 00 00       	callq  404c00 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_>
  4039ff:	83 eb 01             	sub    $0x1,%ebx
  403a02:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  403a07:	75 dd                	jne    4039e6 <_Z32MethodPointerUpdateExampleTimersv+0xa6>
	{
		create_types.emplace_back(entity_hermite::type);
	}

	shuffle(create_types.begin(), create_types.end(), generator);
  403a09:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
  403a0e:	48 8d 54 24 10       	lea    0x10(%rsp),%rdx
  403a13:	e8 c8 15 00 00       	callq  404fe0 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_>
  403a18:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
  403a1d:	4c 8b 64 24 38       	mov    0x38(%rsp),%r12
  403a22:	48 c7 44 24 50 00 00 	movq   $0x0,0x50(%rsp)
  403a29:	00 00 
  403a2b:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
  403a32:	00 00 
  403a34:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
  403a3b:	00 00 

	vector<unique_ptr<entity>> entity_vec;
	for (auto &create_type : create_types)
  403a3d:	4c 39 e3             	cmp    %r12,%rbx
  403a40:	0f 84 81 03 00 00    	je     403dc7 <_Z32MethodPointerUpdateExampleTimersv+0x487>
  403a46:	0f 57 db             	xorps  %xmm3,%xmm3
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
	  if (__m)
	    __res %= __m;
  403a49:	48 bd 05 00 00 00 02 	movabs $0x200000005,%rbp
  403a50:	00 00 00 
  403a53:	f3 0f 11 5c 24 0c    	movss  %xmm3,0xc(%rsp)
  403a59:	e9 06 01 00 00       	jmpq   403b64 <_Z32MethodPointerUpdateExampleTimersv+0x224>
  403a5e:	66 90                	xchg   %ax,%ax
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  403a60:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  403a65:	48 69 f0 a7 41 00 00 	imul   $0x41a7,%rax,%rsi
	  if (__m)
	    __res %= __m;
  403a6c:	48 89 f0             	mov    %rsi,%rax
  403a6f:	48 f7 e5             	mul    %rbp
  403a72:	48 89 f0             	mov    %rsi,%rax
  403a75:	48 29 d0             	sub    %rdx,%rax
  403a78:	48 d1 e8             	shr    %rax
  403a7b:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  403a7f:	48 c1 e9 1e          	shr    $0x1e,%rcx
  403a83:	48 89 c8             	mov    %rcx,%rax
  403a86:	48 c1 e0 1f          	shl    $0x1f,%rax
  403a8a:	48 29 c8             	sub    %rcx,%rax
  403a8d:	48 89 f1             	mov    %rsi,%rcx
  403a90:	48 29 c1             	sub    %rax,%rcx
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  403a93:	48 69 f1 a7 41 00 00 	imul   $0x41a7,%rcx,%rsi
	  if (__m)
	    __res %= __m;
  403a9a:	48 89 f0             	mov    %rsi,%rax
  403a9d:	48 f7 e5             	mul    %rbp
  403aa0:	48 89 f0             	mov    %rsi,%rax
  403aa3:	48 29 d0             	sub    %rdx,%rax
  403aa6:	48 d1 e8             	shr    %rax
  403aa9:	48 01 c2             	add    %rax,%rdx
  403aac:	48 c1 ea 1e          	shr    $0x1e,%rdx
  403ab0:	48 89 d0             	mov    %rdx,%rax
  403ab3:	48 c1 e0 1f          	shl    $0x1f,%rax
  403ab7:	48 29 d0             	sub    %rdx,%rax
  403aba:	48 29 c6             	sub    %rax,%rsi
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  403abd:	48 83 e9 01          	sub    $0x1,%rcx
  403ac1:	48 89 f2             	mov    %rsi,%rdx
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  403ac4:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  403ac9:	0f 88 51 02 00 00    	js     403d20 <_Z32MethodPointerUpdateExampleTimersv+0x3e0>
  403acf:	f3 48 0f 2a c9       	cvtsi2ss %rcx,%xmm1
  403ad4:	f3 0f 10 64 24 0c    	movss  0xc(%rsp),%xmm4
  403ada:	48 83 ea 01          	sub    $0x1,%rdx
  403ade:	f3 0f 58 cc          	addss  %xmm4,%xmm1
	  __tmp *= __r;
	}
      return __sum / __tmp;
  403ae2:	f3 0f 59 0d e2 1d 00 	mulss  0x1de2(%rip),%xmm1        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  403ae9:	00 
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{
	  __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
	    __aurng(__urng);
	  return (__aurng() * (__p.b() - __p.a())) + __p.a();
  403aea:	f3 0f 58 cc          	addss  %xmm4,%xmm1
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  403aee:	0f 88 0c 02 00 00    	js     403d00 <_Z32MethodPointerUpdateExampleTimersv+0x3c0>
  403af4:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  403af9:	f3 0f 10 6c 24 0c    	movss  0xc(%rsp),%xmm5
  403aff:	f3 0f 58 c5          	addss  %xmm5,%xmm0
	  __tmp *= __r;
	}
      return __sum / __tmp;
  403b03:	f3 0f 59 05 c1 1d 00 	mulss  0x1dc1(%rip),%xmm0        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  403b0a:	00 
  403b0b:	f3 0f 58 c5          	addss  %xmm5,%xmm0
			unique_ptr<entity> a(create_entity_hermite(distribution(generator), distribution(generator), distribution(generator), distribution(generator)));
			entity_vec.emplace_back(std::move(a));
		}
		else
		{
			unique_ptr<entity> a(create_entity_lerp_fast(distribution(generator), distribution(generator)));
  403b0f:	e8 ac f3 ff ff       	callq  402ec0 <_Z23create_entity_lerp_fastff>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  403b14:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  403b19:	48 3b 54 24 60       	cmp    0x60(%rsp),%rdx
  403b1e:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  403b23:	0f 84 87 02 00 00    	je     403db0 <_Z32MethodPointerUpdateExampleTimersv+0x470>
  403b29:	48 85 d2             	test   %rdx,%rdx
  403b2c:	0f 84 0e 02 00 00    	je     403d40 <_Z32MethodPointerUpdateExampleTimersv+0x400>
      // Modifiers.
      pointer
      release() noexcept
      {
	pointer __p = get();
	std::get<0>(_M_t) = pointer();
  403b32:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
  403b39:	00 00 
  403b3b:	48 89 02             	mov    %rax,(%rdx)
  403b3e:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  403b43:	48 83 c2 08          	add    $0x8,%rdx
  403b47:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  403b4c:	48 85 ff             	test   %rdi,%rdi
  403b4f:	74 06                	je     403b57 <_Z32MethodPointerUpdateExampleTimersv+0x217>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  403b51:	48 8b 07             	mov    (%rdi),%rax
  403b54:	ff 50 18             	callq  *0x18(%rax)
  403b57:	48 83 c3 08          	add    $0x8,%rbx
	}

	shuffle(create_types.begin(), create_types.end(), generator);

	vector<unique_ptr<entity>> entity_vec;
	for (auto &create_type : create_types)
  403b5b:	49 39 dc             	cmp    %rbx,%r12
  403b5e:	0f 84 6c 02 00 00    	je     403dd0 <_Z32MethodPointerUpdateExampleTimersv+0x490>
	{
		if (create_type == entity_hermite::type)
  403b64:	48 8b 05 a5 1c 00 00 	mov    0x1ca5(%rip),%rax        # 405810 <_ZN14entity_hermite4typeE>
  403b6b:	48 39 03             	cmp    %rax,(%rbx)
  403b6e:	0f 85 ec fe ff ff    	jne    403a60 <_Z32MethodPointerUpdateExampleTimersv+0x120>
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  403b74:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  403b79:	48 69 ca a7 41 00 00 	imul   $0x41a7,%rdx,%rcx
	  if (__m)
	    __res %= __m;
  403b80:	48 89 c8             	mov    %rcx,%rax
  403b83:	48 f7 e5             	mul    %rbp
  403b86:	48 89 c8             	mov    %rcx,%rax
  403b89:	48 29 d0             	sub    %rdx,%rax
  403b8c:	48 d1 e8             	shr    %rax
  403b8f:	48 8d 3c 02          	lea    (%rdx,%rax,1),%rdi
  403b93:	48 c1 ef 1e          	shr    $0x1e,%rdi
  403b97:	48 89 f8             	mov    %rdi,%rax
  403b9a:	48 c1 e0 1f          	shl    $0x1f,%rax
  403b9e:	48 29 f8             	sub    %rdi,%rax
  403ba1:	48 29 c1             	sub    %rax,%rcx
  403ba4:	48 89 cf             	mov    %rcx,%rdi
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  403ba7:	48 69 c9 a7 41 00 00 	imul   $0x41a7,%rcx,%rcx
	  if (__m)
	    __res %= __m;
  403bae:	48 89 c8             	mov    %rcx,%rax
  403bb1:	48 f7 e5             	mul    %rbp
  403bb4:	48 89 c8             	mov    %rcx,%rax
  403bb7:	48 29 d0             	sub    %rdx,%rax
  403bba:	48 d1 e8             	shr    %rax
  403bbd:	48 8d 34 02          	lea    (%rdx,%rax,1),%rsi
  403bc1:	48 c1 ee 1e          	shr    $0x1e,%rsi
  403bc5:	48 89 f0             	mov    %rsi,%rax
  403bc8:	48 c1 e0 1f          	shl    $0x1f,%rax
  403bcc:	48 29 f0             	sub    %rsi,%rax
  403bcf:	48 29 c1             	sub    %rax,%rcx
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  403bd2:	4c 69 c1 a7 41 00 00 	imul   $0x41a7,%rcx,%r8
	  if (__m)
	    __res %= __m;
  403bd9:	48 89 ce             	mov    %rcx,%rsi
  403bdc:	4c 89 c0             	mov    %r8,%rax
  403bdf:	48 f7 e5             	mul    %rbp
  403be2:	4c 89 c0             	mov    %r8,%rax
  403be5:	48 29 d0             	sub    %rdx,%rax
  403be8:	48 d1 e8             	shr    %rax
  403beb:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  403bef:	48 c1 e9 1e          	shr    $0x1e,%rcx
  403bf3:	48 89 c8             	mov    %rcx,%rax
  403bf6:	48 c1 e0 1f          	shl    $0x1f,%rax
  403bfa:	48 29 c8             	sub    %rcx,%rax
  403bfd:	4c 89 c1             	mov    %r8,%rcx
  403c00:	48 29 c1             	sub    %rax,%rcx
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  403c03:	4c 69 c1 a7 41 00 00 	imul   $0x41a7,%rcx,%r8
	  if (__m)
	    __res %= __m;
  403c0a:	4c 89 c0             	mov    %r8,%rax
  403c0d:	48 f7 e5             	mul    %rbp
  403c10:	4c 89 c0             	mov    %r8,%rax
  403c13:	48 29 d0             	sub    %rdx,%rax
  403c16:	48 d1 e8             	shr    %rax
  403c19:	48 01 c2             	add    %rax,%rdx
  403c1c:	48 c1 ea 1e          	shr    $0x1e,%rdx
  403c20:	48 89 d0             	mov    %rdx,%rax
  403c23:	48 c1 e0 1f          	shl    $0x1f,%rax
  403c27:	48 29 d0             	sub    %rdx,%rax
  403c2a:	4c 89 c2             	mov    %r8,%rdx
  403c2d:	48 29 c2             	sub    %rax,%rdx
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  403c30:	48 83 ef 01          	sub    $0x1,%rdi
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  403c34:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  403c39:	0f 88 23 01 00 00    	js     403d62 <_Z32MethodPointerUpdateExampleTimersv+0x422>
  403c3f:	f3 48 0f 2a df       	cvtsi2ss %rdi,%xmm3
  403c44:	f3 0f 10 7c 24 0c    	movss  0xc(%rsp),%xmm7
  403c4a:	48 83 ee 01          	sub    $0x1,%rsi
  403c4e:	f3 0f 58 df          	addss  %xmm7,%xmm3
	  __tmp *= __r;
	}
      return __sum / __tmp;
  403c52:	f3 0f 59 1d 72 1c 00 	mulss  0x1c72(%rip),%xmm3        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  403c59:	00 
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{
	  __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
	    __aurng(__urng);
	  return (__aurng() * (__p.b() - __p.a())) + __p.a();
  403c5a:	f3 0f 58 df          	addss  %xmm7,%xmm3
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  403c5e:	0f 88 32 01 00 00    	js     403d96 <_Z32MethodPointerUpdateExampleTimersv+0x456>
  403c64:	f3 48 0f 2a d6       	cvtsi2ss %rsi,%xmm2
  403c69:	f3 0f 10 7c 24 0c    	movss  0xc(%rsp),%xmm7
  403c6f:	48 83 e9 01          	sub    $0x1,%rcx
  403c73:	f3 0f 58 d7          	addss  %xmm7,%xmm2
	  __tmp *= __r;
	}
      return __sum / __tmp;
  403c77:	f3 0f 59 15 4d 1c 00 	mulss  0x1c4d(%rip),%xmm2        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  403c7e:	00 
  403c7f:	f3 0f 58 d7          	addss  %xmm7,%xmm2
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  403c83:	0f 88 f3 00 00 00    	js     403d7c <_Z32MethodPointerUpdateExampleTimersv+0x43c>
  403c89:	f3 48 0f 2a c9       	cvtsi2ss %rcx,%xmm1
  403c8e:	f3 0f 10 74 24 0c    	movss  0xc(%rsp),%xmm6
  403c94:	48 83 ea 01          	sub    $0x1,%rdx
  403c98:	f3 0f 58 ce          	addss  %xmm6,%xmm1
	  __tmp *= __r;
	}
      return __sum / __tmp;
  403c9c:	f3 0f 59 0d 28 1c 00 	mulss  0x1c28(%rip),%xmm1        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  403ca3:	00 
  403ca4:	f3 0f 58 ce          	addss  %xmm6,%xmm1
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  403ca8:	0f 88 9a 00 00 00    	js     403d48 <_Z32MethodPointerUpdateExampleTimersv+0x408>
  403cae:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  403cb3:	f3 0f 10 7c 24 0c    	movss  0xc(%rsp),%xmm7
  403cb9:	f3 0f 58 c7          	addss  %xmm7,%xmm0
	  __tmp *= __r;
	}
      return __sum / __tmp;
  403cbd:	f3 0f 59 05 07 1c 00 	mulss  0x1c07(%rip),%xmm0        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  403cc4:	00 
  403cc5:	f3 0f 58 c7          	addss  %xmm7,%xmm0
		{
			unique_ptr<entity> a(create_entity_hermite(distribution(generator), distribution(generator), distribution(generator), distribution(generator)));
  403cc9:	e8 02 f5 ff ff       	callq  4031d0 <_Z21create_entity_hermiteffff>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  403cce:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  403cd3:	48 3b 54 24 60       	cmp    0x60(%rsp),%rdx
  403cd8:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  403cdd:	0f 85 46 fe ff ff    	jne    403b29 <_Z32MethodPointerUpdateExampleTimersv+0x1e9>
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  403ce3:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  403ce8:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  403ced:	4c 89 ef             	mov    %r13,%rdi
  403cf0:	e8 cb 14 00 00       	callq  4051c0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_>
  403cf5:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  403cfa:	e9 4d fe ff ff       	jmpq   403b4c <_Z32MethodPointerUpdateExampleTimersv+0x20c>
  403cff:	90                   	nop
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  403d00:	48 89 d0             	mov    %rdx,%rax
  403d03:	83 e2 01             	and    $0x1,%edx
  403d06:	48 d1 e8             	shr    %rax
  403d09:	48 09 d0             	or     %rdx,%rax
  403d0c:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  403d11:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  403d15:	e9 df fd ff ff       	jmpq   403af9 <_Z32MethodPointerUpdateExampleTimersv+0x1b9>
  403d1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  403d20:	48 89 c8             	mov    %rcx,%rax
  403d23:	83 e1 01             	and    $0x1,%ecx
  403d26:	48 d1 e8             	shr    %rax
  403d29:	48 09 c8             	or     %rcx,%rax
  403d2c:	f3 48 0f 2a c8       	cvtsi2ss %rax,%xmm1
  403d31:	f3 0f 58 c9          	addss  %xmm1,%xmm1
  403d35:	e9 9a fd ff ff       	jmpq   403ad4 <_Z32MethodPointerUpdateExampleTimersv+0x194>
  403d3a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  403d40:	48 89 c7             	mov    %rax,%rdi
  403d43:	e9 fb fd ff ff       	jmpq   403b43 <_Z32MethodPointerUpdateExampleTimersv+0x203>
  403d48:	48 89 d0             	mov    %rdx,%rax
  403d4b:	83 e2 01             	and    $0x1,%edx
  403d4e:	48 d1 e8             	shr    %rax
  403d51:	48 09 d0             	or     %rdx,%rax
  403d54:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  403d59:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  403d5d:	e9 51 ff ff ff       	jmpq   403cb3 <_Z32MethodPointerUpdateExampleTimersv+0x373>
  403d62:	48 89 f8             	mov    %rdi,%rax
  403d65:	83 e7 01             	and    $0x1,%edi
  403d68:	48 d1 e8             	shr    %rax
  403d6b:	48 09 f8             	or     %rdi,%rax
  403d6e:	f3 48 0f 2a d8       	cvtsi2ss %rax,%xmm3
  403d73:	f3 0f 58 db          	addss  %xmm3,%xmm3
  403d77:	e9 c8 fe ff ff       	jmpq   403c44 <_Z32MethodPointerUpdateExampleTimersv+0x304>
  403d7c:	48 89 c8             	mov    %rcx,%rax
  403d7f:	83 e1 01             	and    $0x1,%ecx
  403d82:	48 d1 e8             	shr    %rax
  403d85:	48 09 c8             	or     %rcx,%rax
  403d88:	f3 48 0f 2a c8       	cvtsi2ss %rax,%xmm1
  403d8d:	f3 0f 58 c9          	addss  %xmm1,%xmm1
  403d91:	e9 f8 fe ff ff       	jmpq   403c8e <_Z32MethodPointerUpdateExampleTimersv+0x34e>
  403d96:	48 89 f0             	mov    %rsi,%rax
  403d99:	83 e6 01             	and    $0x1,%esi
  403d9c:	48 d1 e8             	shr    %rax
  403d9f:	48 09 f0             	or     %rsi,%rax
  403da2:	f3 48 0f 2a d0       	cvtsi2ss %rax,%xmm2
  403da7:	f3 0f 58 d2          	addss  %xmm2,%xmm2
  403dab:	e9 b9 fe ff ff       	jmpq   403c69 <_Z32MethodPointerUpdateExampleTimersv+0x329>
  403db0:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  403db5:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  403dba:	4c 89 ef             	mov    %r13,%rdi
  403dbd:	e8 fe 13 00 00       	callq  4051c0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_>
  403dc2:	e9 2e ff ff ff       	jmpq   403cf5 <_Z32MethodPointerUpdateExampleTimersv+0x3b5>
  403dc7:	0f 57 d2             	xorps  %xmm2,%xmm2
  403dca:	f3 0f 11 54 24 0c    	movss  %xmm2,0xc(%rsp)
public:
	std::chrono::time_point<std::chrono::high_resolution_clock> m_start;
	std::chrono::time_point<std::chrono::high_resolution_clock> m_end;
	mytimer()
	{
		m_start = std::chrono::high_resolution_clock::now();
  403dd0:	e8 bb e7 ff ff       	callq  402590 <_ZNSt6chrono3_V212system_clock3nowEv@plt>
  403dd5:	41 bc 14 00 00 00    	mov    $0x14,%r12d
  403ddb:	49 89 c5             	mov    %rax,%r13
  403dde:	66 90                	xchg   %ax,%ax
  403de0:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
  403de5:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
		// The GCC extention looks like you can do this. 
		memfun mf = &entity::Update;

		as_normfun snf = (as_normfun)(&entity_lerp_fast_impl::Update);
		for (float t = 0.0f; t < 1.0; t += 0.05f) {
			for (auto &a : entity_vec) {
  403dea:	48 39 eb             	cmp    %rbp,%rbx
  403ded:	74 24                	je     403e13 <_Z32MethodPointerUpdateExampleTimersv+0x4d3>
  403def:	90                   	nop
	return get();
      }

      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
  403df0:	48 8b 3b             	mov    (%rbx),%rdi
				
				const entity& e = *(&(*a)); 

				as_normfun dnf = (as_normfun)(e.*mf);
  403df3:	48 8b 07             	mov    (%rdi),%rax
  403df6:	48 8b 10             	mov    (%rax),%rdx
				// if we have a fast loop for this object don't update
				// so in this case we on the hermite entity but not the lerp ones. 
				if (snf != dnf) {
  403df9:	48 81 fa 80 2c 40 00 	cmp    $0x402c80,%rdx
  403e00:	74 08                	je     403e0a <_Z32MethodPointerUpdateExampleTimersv+0x4ca>
					a->Update(t);
  403e02:	f3 0f 10 44 24 0c    	movss  0xc(%rsp),%xmm0
  403e08:	ff d2                	callq  *%rdx
  403e0a:	48 83 c3 08          	add    $0x8,%rbx
		// The GCC extention looks like you can do this. 
		memfun mf = &entity::Update;

		as_normfun snf = (as_normfun)(&entity_lerp_fast_impl::Update);
		for (float t = 0.0f; t < 1.0; t += 0.05f) {
			for (auto &a : entity_vec) {
  403e0e:	48 39 dd             	cmp    %rbx,%rbp
  403e11:	75 dd                	jne    403df0 <_Z32MethodPointerUpdateExampleTimersv+0x4b0>
				if (snf != dnf) {
					a->Update(t);
				}
			}
			// fast loop with no virtual functions and maybe a different data format. 
			entity_lerp_fast::UpdateAll(t);
  403e13:	f3 0f 10 44 24 0c    	movss  0xc(%rsp),%xmm0
  403e19:	e8 42 ef ff ff       	callq  402d60 <_ZN16entity_lerp_fast9UpdateAllEf>
		// create a member function that points to update function that I have a fast loop for 
		// The GCC extention looks like you can do this. 
		memfun mf = &entity::Update;

		as_normfun snf = (as_normfun)(&entity_lerp_fast_impl::Update);
		for (float t = 0.0f; t < 1.0; t += 0.05f) {
  403e1e:	f3 0f 10 35 a2 1a 00 	movss  0x1aa2(%rip),%xmm6        # 4058c8 <_ZN14entity_hermite4typeE+0xb8>
  403e25:	00 
  403e26:	41 83 ec 01          	sub    $0x1,%r12d
  403e2a:	f3 0f 58 74 24 0c    	addss  0xc(%rsp),%xmm6
  403e30:	f3 0f 11 74 24 0c    	movss  %xmm6,0xc(%rsp)
  403e36:	75 a8                	jne    403de0 <_Z32MethodPointerUpdateExampleTimersv+0x4a0>
	{
		m_start = std::chrono::high_resolution_clock::now();
	}
	std::chrono::duration<double> stop()
	{
		m_end = std::chrono::high_resolution_clock::now();
  403e38:	e8 53 e7 ff ff       	callq  402590 <_ZNSt6chrono3_V212system_clock3nowEv@plt>
		const duration<_Rep2, _Period2>& __rhs)
      {
	typedef duration<_Rep1, _Period1>			__dur1;
	typedef duration<_Rep2, _Period2>			__dur2;
	typedef typename common_type<__dur1,__dur2>::type	__cd;
	return __cd(__cd(__lhs).count() - __cd(__rhs).count());
  403e3d:	4c 29 e8             	sub    %r13,%rax
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(
	      static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));
  403e40:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  403e45:	48 8b 05 7c 34 20 00 	mov    0x20347c(%rip),%rax        # 6072c8 <gMethodPointerUpdateExampleTimers+0x8>
  403e4c:	48 3b 05 7d 34 20 00 	cmp    0x20347d(%rip),%rax        # 6072d0 <gMethodPointerUpdateExampleTimers+0x10>
  403e53:	f2 0f 5e 05 65 1a 00 	divsd  0x1a65(%rip),%xmm0        # 4058c0 <_ZN14entity_hermite4typeE+0xb0>
  403e5a:	00 
				}
			}
			// fast loop with no virtual functions and maybe a different data format. 
			entity_lerp_fast::UpdateAll(t);
		}
		gMethodPointerUpdateExampleTimers.emplace_back(timer.stop());
  403e5b:	f2 0f 11 44 24 20    	movsd  %xmm0,0x20(%rsp)
  403e61:	74 74                	je     403ed7 <_Z32MethodPointerUpdateExampleTimersv+0x597>
  403e63:	48 85 c0             	test   %rax,%rax
  403e66:	74 0c                	je     403e74 <_Z32MethodPointerUpdateExampleTimersv+0x534>
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(
	      static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));
  403e68:	f2 0f 59 05 48 1a 00 	mulsd  0x1a48(%rip),%xmm0        # 4058b8 <_ZN14entity_hermite4typeE+0xa8>
  403e6f:	00 
	template<typename _Rep2, typename _Period2, typename = typename
	       enable_if<treat_as_floating_point<rep>::value
			 || (ratio_divide<_Period2, period>::den == 1
			     && !treat_as_floating_point<_Rep2>::value)>::type>
	  constexpr duration(const duration<_Rep2, _Period2>& __d)
	  : __r(duration_cast<duration>(__d).count()) { }
  403e70:	f2 0f 11 00          	movsd  %xmm0,(%rax)
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }
  403e74:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
  403e79:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  403e7e:	48 83 c0 08          	add    $0x8,%rax
  403e82:	48 89 05 3f 34 20 00 	mov    %rax,0x20343f(%rip)        # 6072c8 <gMethodPointerUpdateExampleTimers+0x8>
  403e89:	48 39 dd             	cmp    %rbx,%rbp
  403e8c:	74 67                	je     403ef5 <_Z32MethodPointerUpdateExampleTimersv+0x5b5>
  403e8e:	66 90                	xchg   %ax,%ax

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  403e90:	48 8b 3b             	mov    (%rbx),%rdi
  403e93:	48 85 ff             	test   %rdi,%rdi
  403e96:	74 06                	je     403e9e <_Z32MethodPointerUpdateExampleTimersv+0x55e>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  403e98:	48 8b 07             	mov    (%rdi),%rax
  403e9b:	ff 50 18             	callq  *0x18(%rax)
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
	  get_deleter()(__ptr);
	__ptr = pointer();
  403e9e:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
  403ea5:	48 83 c3 08          	add    $0x8,%rbx
  403ea9:	48 39 dd             	cmp    %rbx,%rbp
  403eac:	75 e2                	jne    403e90 <_Z32MethodPointerUpdateExampleTimersv+0x550>
  403eae:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  403eb3:	48 85 ff             	test   %rdi,%rdi
  403eb6:	74 05                	je     403ebd <_Z32MethodPointerUpdateExampleTimersv+0x57d>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  403eb8:	e8 93 e6 ff ff       	callq  402550 <_ZdlPv@plt>
      }
#endif

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  403ebd:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  403ec2:	48 85 ff             	test   %rdi,%rdi
  403ec5:	74 05                	je     403ecc <_Z32MethodPointerUpdateExampleTimersv+0x58c>
  403ec7:	e8 84 e6 ff ff       	callq  402550 <_ZdlPv@plt>
	}
}
  403ecc:	48 83 c4 78          	add    $0x78,%rsp
  403ed0:	5b                   	pop    %rbx
  403ed1:	5d                   	pop    %rbp
  403ed2:	41 5c                	pop    %r12
  403ed4:	41 5d                	pop    %r13
  403ed6:	c3                   	retq   
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  403ed7:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  403edc:	bf c0 72 60 00       	mov    $0x6072c0,%edi
  403ee1:	e8 3a 14 00 00       	callq  405320 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EE19_M_emplace_back_auxIINS1_IdS2_ILl1ELl1EEEEEEEvDpOT_>
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }
  403ee6:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
  403eeb:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
  403ef0:	48 39 dd             	cmp    %rbx,%rbp
  403ef3:	75 9b                	jne    403e90 <_Z32MethodPointerUpdateExampleTimersv+0x550>
  403ef5:	48 89 ef             	mov    %rbp,%rdi
  403ef8:	eb b9                	jmp    403eb3 <_Z32MethodPointerUpdateExampleTimersv+0x573>
  403efa:	48 89 c3             	mov    %rax,%rbx
      }
#endif

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  403efd:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  403f02:	48 85 ff             	test   %rdi,%rdi
  403f05:	74 05                	je     403f0c <_Z32MethodPointerUpdateExampleTimersv+0x5cc>
  403f07:	e8 44 e6 ff ff       	callq  402550 <_ZdlPv@plt>
  403f0c:	48 89 df             	mov    %rbx,%rdi
  403f0f:	e8 1c e7 ff ff       	callq  402630 <_Unwind_Resume@plt>

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  403f14:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  403f19:	48 89 c3             	mov    %rax,%rbx
  403f1c:	48 85 ff             	test   %rdi,%rdi
  403f1f:	74 06                	je     403f27 <_Z32MethodPointerUpdateExampleTimersv+0x5e7>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  403f21:	48 8b 07             	mov    (%rdi),%rax
  403f24:	ff 50 18             	callq  *0x18(%rax)
		create_types.emplace_back(entity_hermite::type);
	}

	shuffle(create_types.begin(), create_types.end(), generator);

	vector<unique_ptr<entity>> entity_vec;
  403f27:	4c 89 ef             	mov    %r13,%rdi
  403f2a:	e8 71 0c 00 00       	callq  404ba0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EED1Ev>
  403f2f:	eb cc                	jmp    403efd <_Z32MethodPointerUpdateExampleTimersv+0x5bd>
  403f31:	eb e1                	jmp    403f14 <_Z32MethodPointerUpdateExampleTimersv+0x5d4>
  403f33:	48 89 c3             	mov    %rax,%rbx
  403f36:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  403f3b:	eb ea                	jmp    403f27 <_Z32MethodPointerUpdateExampleTimersv+0x5e7>
  403f3d:	0f 1f 00             	nopl   (%rax)

0000000000403f40 <_Z23FastUpdateExampleTimersv>:
	}
}


void FastUpdateExampleTimers()
{
  403f40:	41 56                	push   %r14
	pointer _M_start;
	pointer _M_finish;
	pointer _M_end_of_storage;

	_Vector_impl()
	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
  403f42:	31 c0                	xor    %eax,%eax
  403f44:	31 f6                	xor    %esi,%esi
  403f46:	41 55                	push   %r13
  403f48:	41 54                	push   %r12
  403f4a:	55                   	push   %rbp
  403f4b:	53                   	push   %rbx
  403f4c:	bb 90 01 00 00       	mov    $0x190,%ebx
  403f51:	48 83 ec 70          	sub    $0x70,%rsp

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  403f55:	48 8b 2d 9c 17 00 00 	mov    0x179c(%rip),%rbp        # 4056f8 <_ZN16entity_lerp_fast4typeE>
    {
      if ((__detail::__mod<_UIntType, __m>(__c) == 0)
	  && (__detail::__mod<_UIntType, __m>(__s) == 0))
	_M_x = 1;
      else
	_M_x = __detail::__mod<_UIntType, __m>(__s);
  403f5c:	48 c7 44 24 10 01 00 	movq   $0x1,0x10(%rsp)
  403f63:	00 00 
  403f65:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
  403f6c:	00 00 
  403f6e:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
  403f75:	00 00 
  403f77:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
  403f7e:	00 00 
  403f80:	eb 1c                	jmp    403f9e <_Z23FastUpdateExampleTimersv+0x5e>
  403f82:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  403f88:	48 85 f6             	test   %rsi,%rsi
  403f8b:	74 03                	je     403f90 <_Z23FastUpdateExampleTimersv+0x50>
  403f8d:	48 89 2e             	mov    %rbp,(%rsi)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  403f90:	48 83 c6 08          	add    $0x8,%rsi
	uniform_real_distribution<float> distribution(0, 1);

	int number_of_lerp = 400;
	int number_of_hermite = 1000;
	vector<long long> create_types;
	for (int i = 0; i < number_of_lerp; i++)
  403f94:	83 eb 01             	sub    $0x1,%ebx
  403f97:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
  403f9c:	74 23                	je     403fc1 <_Z23FastUpdateExampleTimersv+0x81>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  403f9e:	48 39 c6             	cmp    %rax,%rsi
  403fa1:	75 e5                	jne    403f88 <_Z23FastUpdateExampleTimersv+0x48>
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  403fa3:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  403fa8:	be f8 56 40 00       	mov    $0x4056f8,%esi
  403fad:	e8 4e 0c 00 00       	callq  404c00 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_>
  403fb2:	83 eb 01             	sub    $0x1,%ebx
  403fb5:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  403fba:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  403fbf:	75 dd                	jne    403f9e <_Z23FastUpdateExampleTimersv+0x5e>
  403fc1:	bb e8 03 00 00       	mov    $0x3e8,%ebx
  403fc6:	48 8b 2d 43 18 00 00 	mov    0x1843(%rip),%rbp        # 405810 <_ZN14entity_hermite4typeE>
  403fcd:	eb 1c                	jmp    403feb <_Z23FastUpdateExampleTimersv+0xab>
  403fcf:	90                   	nop
  403fd0:	48 85 f6             	test   %rsi,%rsi
  403fd3:	74 03                	je     403fd8 <_Z23FastUpdateExampleTimersv+0x98>
  403fd5:	48 89 2e             	mov    %rbp,(%rsi)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  403fd8:	48 83 c6 08          	add    $0x8,%rsi
	{
		create_types.emplace_back(entity_lerp_fast::type);
	}
	for (int i = 0; i < number_of_hermite; i++)
  403fdc:	83 eb 01             	sub    $0x1,%ebx
  403fdf:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
  403fe4:	74 23                	je     404009 <_Z23FastUpdateExampleTimersv+0xc9>
  403fe6:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  403feb:	48 39 c6             	cmp    %rax,%rsi
  403fee:	75 e0                	jne    403fd0 <_Z23FastUpdateExampleTimersv+0x90>
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  403ff0:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  403ff5:	be 10 58 40 00       	mov    $0x405810,%esi
  403ffa:	e8 01 0c 00 00       	callq  404c00 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_>
  403fff:	83 eb 01             	sub    $0x1,%ebx
  404002:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  404007:	75 dd                	jne    403fe6 <_Z23FastUpdateExampleTimersv+0xa6>
	{
		create_types.emplace_back(entity_hermite::type);
	}

	shuffle(create_types.begin(), create_types.end(), generator);
  404009:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
  40400e:	48 8d 54 24 10       	lea    0x10(%rsp),%rdx
  404013:	e8 c8 0f 00 00       	callq  404fe0 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_>
  404018:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
  40401d:	4c 8b 64 24 38       	mov    0x38(%rsp),%r12
  404022:	48 c7 44 24 50 00 00 	movq   $0x0,0x50(%rsp)
  404029:	00 00 
  40402b:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
  404032:	00 00 
  404034:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
  40403b:	00 00 

	vector<unique_ptr<entity>> entity_vec;
	for (auto &create_type : create_types)
  40403d:	4c 39 e3             	cmp    %r12,%rbx
  404040:	0f 84 81 03 00 00    	je     4043c7 <_Z23FastUpdateExampleTimersv+0x487>
  404046:	0f 57 db             	xorps  %xmm3,%xmm3
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
	  if (__m)
	    __res %= __m;
  404049:	48 bd 05 00 00 00 02 	movabs $0x200000005,%rbp
  404050:	00 00 00 
  404053:	f3 0f 11 5c 24 0c    	movss  %xmm3,0xc(%rsp)
  404059:	e9 06 01 00 00       	jmpq   404164 <_Z23FastUpdateExampleTimersv+0x224>
  40405e:	66 90                	xchg   %ax,%ax
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404060:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  404065:	48 69 f0 a7 41 00 00 	imul   $0x41a7,%rax,%rsi
	  if (__m)
	    __res %= __m;
  40406c:	48 89 f0             	mov    %rsi,%rax
  40406f:	48 f7 e5             	mul    %rbp
  404072:	48 89 f0             	mov    %rsi,%rax
  404075:	48 29 d0             	sub    %rdx,%rax
  404078:	48 d1 e8             	shr    %rax
  40407b:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  40407f:	48 c1 e9 1e          	shr    $0x1e,%rcx
  404083:	48 89 c8             	mov    %rcx,%rax
  404086:	48 c1 e0 1f          	shl    $0x1f,%rax
  40408a:	48 29 c8             	sub    %rcx,%rax
  40408d:	48 89 f1             	mov    %rsi,%rcx
  404090:	48 29 c1             	sub    %rax,%rcx
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404093:	48 69 f1 a7 41 00 00 	imul   $0x41a7,%rcx,%rsi
	  if (__m)
	    __res %= __m;
  40409a:	48 89 f0             	mov    %rsi,%rax
  40409d:	48 f7 e5             	mul    %rbp
  4040a0:	48 89 f0             	mov    %rsi,%rax
  4040a3:	48 29 d0             	sub    %rdx,%rax
  4040a6:	48 d1 e8             	shr    %rax
  4040a9:	48 01 c2             	add    %rax,%rdx
  4040ac:	48 c1 ea 1e          	shr    $0x1e,%rdx
  4040b0:	48 89 d0             	mov    %rdx,%rax
  4040b3:	48 c1 e0 1f          	shl    $0x1f,%rax
  4040b7:	48 29 d0             	sub    %rdx,%rax
  4040ba:	48 89 f2             	mov    %rsi,%rdx
  4040bd:	48 29 c2             	sub    %rax,%rdx
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  4040c0:	48 83 e9 01          	sub    $0x1,%rcx
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  4040c4:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  4040c9:	0f 88 51 02 00 00    	js     404320 <_Z23FastUpdateExampleTimersv+0x3e0>
  4040cf:	f3 48 0f 2a c9       	cvtsi2ss %rcx,%xmm1
  4040d4:	f3 0f 10 64 24 0c    	movss  0xc(%rsp),%xmm4
  4040da:	48 83 ea 01          	sub    $0x1,%rdx
  4040de:	f3 0f 58 cc          	addss  %xmm4,%xmm1
	  __tmp *= __r;
	}
      return __sum / __tmp;
  4040e2:	f3 0f 59 0d e2 17 00 	mulss  0x17e2(%rip),%xmm1        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  4040e9:	00 
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{
	  __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
	    __aurng(__urng);
	  return (__aurng() * (__p.b() - __p.a())) + __p.a();
  4040ea:	f3 0f 58 cc          	addss  %xmm4,%xmm1
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  4040ee:	0f 88 0c 02 00 00    	js     404300 <_Z23FastUpdateExampleTimersv+0x3c0>
  4040f4:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  4040f9:	f3 0f 10 6c 24 0c    	movss  0xc(%rsp),%xmm5
  4040ff:	f3 0f 58 c5          	addss  %xmm5,%xmm0
	  __tmp *= __r;
	}
      return __sum / __tmp;
  404103:	f3 0f 59 05 c1 17 00 	mulss  0x17c1(%rip),%xmm0        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  40410a:	00 
  40410b:	f3 0f 58 c5          	addss  %xmm5,%xmm0
			unique_ptr<entity> a(create_entity_hermite(distribution(generator), distribution(generator), distribution(generator), distribution(generator)));
			entity_vec.emplace_back(std::move(a));
		}
		else
		{
			unique_ptr<entity> a(create_entity_lerp_fast(distribution(generator), distribution(generator)));
  40410f:	e8 ac ed ff ff       	callq  402ec0 <_Z23create_entity_lerp_fastff>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  404114:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  404119:	48 3b 54 24 60       	cmp    0x60(%rsp),%rdx
  40411e:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  404123:	0f 84 87 02 00 00    	je     4043b0 <_Z23FastUpdateExampleTimersv+0x470>
  404129:	48 85 d2             	test   %rdx,%rdx
  40412c:	0f 84 0e 02 00 00    	je     404340 <_Z23FastUpdateExampleTimersv+0x400>
      // Modifiers.
      pointer
      release() noexcept
      {
	pointer __p = get();
	std::get<0>(_M_t) = pointer();
  404132:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
  404139:	00 00 
  40413b:	48 89 02             	mov    %rax,(%rdx)
  40413e:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  404143:	48 83 c2 08          	add    $0x8,%rdx
  404147:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  40414c:	48 85 ff             	test   %rdi,%rdi
  40414f:	74 06                	je     404157 <_Z23FastUpdateExampleTimersv+0x217>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  404151:	48 8b 07             	mov    (%rdi),%rax
  404154:	ff 50 18             	callq  *0x18(%rax)
  404157:	48 83 c3 08          	add    $0x8,%rbx
	}

	shuffle(create_types.begin(), create_types.end(), generator);

	vector<unique_ptr<entity>> entity_vec;
	for (auto &create_type : create_types)
  40415b:	49 39 dc             	cmp    %rbx,%r12
  40415e:	0f 84 6c 02 00 00    	je     4043d0 <_Z23FastUpdateExampleTimersv+0x490>
	{
		if (create_type == entity_hermite::type)
  404164:	48 8b 05 a5 16 00 00 	mov    0x16a5(%rip),%rax        # 405810 <_ZN14entity_hermite4typeE>
  40416b:	48 39 03             	cmp    %rax,(%rbx)
  40416e:	0f 85 ec fe ff ff    	jne    404060 <_Z23FastUpdateExampleTimersv+0x120>
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404174:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  404179:	48 69 ca a7 41 00 00 	imul   $0x41a7,%rdx,%rcx
	  if (__m)
	    __res %= __m;
  404180:	48 89 c8             	mov    %rcx,%rax
  404183:	48 f7 e5             	mul    %rbp
  404186:	48 89 c8             	mov    %rcx,%rax
  404189:	48 29 d0             	sub    %rdx,%rax
  40418c:	48 d1 e8             	shr    %rax
  40418f:	48 8d 3c 02          	lea    (%rdx,%rax,1),%rdi
  404193:	48 c1 ef 1e          	shr    $0x1e,%rdi
  404197:	48 89 f8             	mov    %rdi,%rax
  40419a:	48 c1 e0 1f          	shl    $0x1f,%rax
  40419e:	48 29 f8             	sub    %rdi,%rax
  4041a1:	48 29 c1             	sub    %rax,%rcx
  4041a4:	48 89 cf             	mov    %rcx,%rdi
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  4041a7:	48 69 c9 a7 41 00 00 	imul   $0x41a7,%rcx,%rcx
	  if (__m)
	    __res %= __m;
  4041ae:	48 89 c8             	mov    %rcx,%rax
  4041b1:	48 f7 e5             	mul    %rbp
  4041b4:	48 89 c8             	mov    %rcx,%rax
  4041b7:	48 29 d0             	sub    %rdx,%rax
  4041ba:	48 d1 e8             	shr    %rax
  4041bd:	48 8d 34 02          	lea    (%rdx,%rax,1),%rsi
  4041c1:	48 c1 ee 1e          	shr    $0x1e,%rsi
  4041c5:	48 89 f0             	mov    %rsi,%rax
  4041c8:	48 c1 e0 1f          	shl    $0x1f,%rax
  4041cc:	48 29 f0             	sub    %rsi,%rax
  4041cf:	48 29 c1             	sub    %rax,%rcx
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  4041d2:	4c 69 c1 a7 41 00 00 	imul   $0x41a7,%rcx,%r8
	  if (__m)
	    __res %= __m;
  4041d9:	48 89 ce             	mov    %rcx,%rsi
  4041dc:	4c 89 c0             	mov    %r8,%rax
  4041df:	48 f7 e5             	mul    %rbp
  4041e2:	4c 89 c0             	mov    %r8,%rax
  4041e5:	48 29 d0             	sub    %rdx,%rax
  4041e8:	48 d1 e8             	shr    %rax
  4041eb:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  4041ef:	48 c1 e9 1e          	shr    $0x1e,%rcx
  4041f3:	48 89 c8             	mov    %rcx,%rax
  4041f6:	48 c1 e0 1f          	shl    $0x1f,%rax
  4041fa:	48 29 c8             	sub    %rcx,%rax
  4041fd:	4c 89 c1             	mov    %r8,%rcx
  404200:	48 29 c1             	sub    %rax,%rcx
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404203:	4c 69 c1 a7 41 00 00 	imul   $0x41a7,%rcx,%r8
	  if (__m)
	    __res %= __m;
  40420a:	4c 89 c0             	mov    %r8,%rax
  40420d:	48 f7 e5             	mul    %rbp
  404210:	4c 89 c0             	mov    %r8,%rax
  404213:	48 29 d0             	sub    %rdx,%rax
  404216:	48 d1 e8             	shr    %rax
  404219:	48 01 c2             	add    %rax,%rdx
  40421c:	48 c1 ea 1e          	shr    $0x1e,%rdx
  404220:	48 89 d0             	mov    %rdx,%rax
  404223:	48 c1 e0 1f          	shl    $0x1f,%rax
  404227:	48 29 d0             	sub    %rdx,%rax
  40422a:	4c 89 c2             	mov    %r8,%rdx
  40422d:	48 29 c2             	sub    %rax,%rdx
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  404230:	48 83 ef 01          	sub    $0x1,%rdi
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  404234:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  404239:	0f 88 23 01 00 00    	js     404362 <_Z23FastUpdateExampleTimersv+0x422>
  40423f:	f3 48 0f 2a df       	cvtsi2ss %rdi,%xmm3
  404244:	f3 0f 10 7c 24 0c    	movss  0xc(%rsp),%xmm7
  40424a:	48 83 ee 01          	sub    $0x1,%rsi
  40424e:	f3 0f 58 df          	addss  %xmm7,%xmm3
	  __tmp *= __r;
	}
      return __sum / __tmp;
  404252:	f3 0f 59 1d 72 16 00 	mulss  0x1672(%rip),%xmm3        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  404259:	00 
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{
	  __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
	    __aurng(__urng);
	  return (__aurng() * (__p.b() - __p.a())) + __p.a();
  40425a:	f3 0f 58 df          	addss  %xmm7,%xmm3
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  40425e:	0f 88 32 01 00 00    	js     404396 <_Z23FastUpdateExampleTimersv+0x456>
  404264:	f3 48 0f 2a d6       	cvtsi2ss %rsi,%xmm2
  404269:	f3 0f 10 7c 24 0c    	movss  0xc(%rsp),%xmm7
  40426f:	48 83 e9 01          	sub    $0x1,%rcx
  404273:	f3 0f 58 d7          	addss  %xmm7,%xmm2
	  __tmp *= __r;
	}
      return __sum / __tmp;
  404277:	f3 0f 59 15 4d 16 00 	mulss  0x164d(%rip),%xmm2        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  40427e:	00 
  40427f:	f3 0f 58 d7          	addss  %xmm7,%xmm2
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  404283:	0f 88 f3 00 00 00    	js     40437c <_Z23FastUpdateExampleTimersv+0x43c>
  404289:	f3 48 0f 2a c9       	cvtsi2ss %rcx,%xmm1
  40428e:	f3 0f 10 74 24 0c    	movss  0xc(%rsp),%xmm6
  404294:	48 83 ea 01          	sub    $0x1,%rdx
  404298:	f3 0f 58 ce          	addss  %xmm6,%xmm1
	  __tmp *= __r;
	}
      return __sum / __tmp;
  40429c:	f3 0f 59 0d 28 16 00 	mulss  0x1628(%rip),%xmm1        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  4042a3:	00 
  4042a4:	f3 0f 58 ce          	addss  %xmm6,%xmm1
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  4042a8:	0f 88 9a 00 00 00    	js     404348 <_Z23FastUpdateExampleTimersv+0x408>
  4042ae:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  4042b3:	f3 0f 10 7c 24 0c    	movss  0xc(%rsp),%xmm7
  4042b9:	f3 0f 58 c7          	addss  %xmm7,%xmm0
	  __tmp *= __r;
	}
      return __sum / __tmp;
  4042bd:	f3 0f 59 05 07 16 00 	mulss  0x1607(%rip),%xmm0        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  4042c4:	00 
  4042c5:	f3 0f 58 c7          	addss  %xmm7,%xmm0
		{
			unique_ptr<entity> a(create_entity_hermite(distribution(generator), distribution(generator), distribution(generator), distribution(generator)));
  4042c9:	e8 02 ef ff ff       	callq  4031d0 <_Z21create_entity_hermiteffff>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  4042ce:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  4042d3:	48 3b 54 24 60       	cmp    0x60(%rsp),%rdx
  4042d8:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  4042dd:	0f 85 46 fe ff ff    	jne    404129 <_Z23FastUpdateExampleTimersv+0x1e9>
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  4042e3:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  4042e8:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  4042ed:	4c 89 ef             	mov    %r13,%rdi
  4042f0:	e8 cb 0e 00 00       	callq  4051c0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_>
  4042f5:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  4042fa:	e9 4d fe ff ff       	jmpq   40414c <_Z23FastUpdateExampleTimersv+0x20c>
  4042ff:	90                   	nop
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  404300:	48 89 d0             	mov    %rdx,%rax
  404303:	83 e2 01             	and    $0x1,%edx
  404306:	48 d1 e8             	shr    %rax
  404309:	48 09 d0             	or     %rdx,%rax
  40430c:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  404311:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  404315:	e9 df fd ff ff       	jmpq   4040f9 <_Z23FastUpdateExampleTimersv+0x1b9>
  40431a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  404320:	48 89 c8             	mov    %rcx,%rax
  404323:	83 e1 01             	and    $0x1,%ecx
  404326:	48 d1 e8             	shr    %rax
  404329:	48 09 c8             	or     %rcx,%rax
  40432c:	f3 48 0f 2a c8       	cvtsi2ss %rax,%xmm1
  404331:	f3 0f 58 c9          	addss  %xmm1,%xmm1
  404335:	e9 9a fd ff ff       	jmpq   4040d4 <_Z23FastUpdateExampleTimersv+0x194>
  40433a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  404340:	48 89 c7             	mov    %rax,%rdi
  404343:	e9 fb fd ff ff       	jmpq   404143 <_Z23FastUpdateExampleTimersv+0x203>
  404348:	48 89 d0             	mov    %rdx,%rax
  40434b:	83 e2 01             	and    $0x1,%edx
  40434e:	48 d1 e8             	shr    %rax
  404351:	48 09 d0             	or     %rdx,%rax
  404354:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  404359:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  40435d:	e9 51 ff ff ff       	jmpq   4042b3 <_Z23FastUpdateExampleTimersv+0x373>
  404362:	48 89 f8             	mov    %rdi,%rax
  404365:	83 e7 01             	and    $0x1,%edi
  404368:	48 d1 e8             	shr    %rax
  40436b:	48 09 f8             	or     %rdi,%rax
  40436e:	f3 48 0f 2a d8       	cvtsi2ss %rax,%xmm3
  404373:	f3 0f 58 db          	addss  %xmm3,%xmm3
  404377:	e9 c8 fe ff ff       	jmpq   404244 <_Z23FastUpdateExampleTimersv+0x304>
  40437c:	48 89 c8             	mov    %rcx,%rax
  40437f:	83 e1 01             	and    $0x1,%ecx
  404382:	48 d1 e8             	shr    %rax
  404385:	48 09 c8             	or     %rcx,%rax
  404388:	f3 48 0f 2a c8       	cvtsi2ss %rax,%xmm1
  40438d:	f3 0f 58 c9          	addss  %xmm1,%xmm1
  404391:	e9 f8 fe ff ff       	jmpq   40428e <_Z23FastUpdateExampleTimersv+0x34e>
  404396:	48 89 f0             	mov    %rsi,%rax
  404399:	83 e6 01             	and    $0x1,%esi
  40439c:	48 d1 e8             	shr    %rax
  40439f:	48 09 f0             	or     %rsi,%rax
  4043a2:	f3 48 0f 2a d0       	cvtsi2ss %rax,%xmm2
  4043a7:	f3 0f 58 d2          	addss  %xmm2,%xmm2
  4043ab:	e9 b9 fe ff ff       	jmpq   404269 <_Z23FastUpdateExampleTimersv+0x329>
  4043b0:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  4043b5:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  4043ba:	4c 89 ef             	mov    %r13,%rdi
  4043bd:	e8 fe 0d 00 00       	callq  4051c0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_>
  4043c2:	e9 2e ff ff ff       	jmpq   4042f5 <_Z23FastUpdateExampleTimersv+0x3b5>
  4043c7:	0f 57 d2             	xorps  %xmm2,%xmm2
  4043ca:	f3 0f 11 54 24 0c    	movss  %xmm2,0xc(%rsp)
public:
	std::chrono::time_point<std::chrono::high_resolution_clock> m_start;
	std::chrono::time_point<std::chrono::high_resolution_clock> m_end;
	mytimer()
	{
		m_start = std::chrono::high_resolution_clock::now();
  4043d0:	e8 bb e1 ff ff       	callq  402590 <_ZNSt6chrono3_V212system_clock3nowEv@plt>
  4043d5:	4c 8b 25 1c 13 00 00 	mov    0x131c(%rip),%r12        # 4056f8 <_ZN16entity_lerp_fast4typeE>
  4043dc:	49 89 c6             	mov    %rax,%r14
  4043df:	41 bd 14 00 00 00    	mov    $0x14,%r13d
  4043e5:	0f 1f 00             	nopl   (%rax)
  4043e8:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
  4043ed:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx

	{
		// change styles for document 
		mytimer timer;
		for (float t = 0.0f; t < 1.0; t += 0.05f) {
			for (auto &a : entity_vec) {
  4043f2:	48 39 eb             	cmp    %rbp,%rbx
  4043f5:	74 29                	je     404420 <_Z23FastUpdateExampleTimersv+0x4e0>
  4043f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4043fe:	00 00 
	return get();
      }

      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
  404400:	48 8b 3b             	mov    (%rbx),%rdi
				// if we have a fast loop for this object don't update
				// so in this case we on the hermite entity but not the lerp ones. 
				if (*a->m_typedata != entity_lerp_fast::type) {
  404403:	48 8b 47 08          	mov    0x8(%rdi),%rax
  404407:	4c 39 20             	cmp    %r12,(%rax)
  40440a:	74 0b                	je     404417 <_Z23FastUpdateExampleTimersv+0x4d7>
					a->Update(t);
  40440c:	48 8b 07             	mov    (%rdi),%rax
  40440f:	f3 0f 10 44 24 0c    	movss  0xc(%rsp),%xmm0
  404415:	ff 10                	callq  *(%rax)
  404417:	48 83 c3 08          	add    $0x8,%rbx

	{
		// change styles for document 
		mytimer timer;
		for (float t = 0.0f; t < 1.0; t += 0.05f) {
			for (auto &a : entity_vec) {
  40441b:	48 39 dd             	cmp    %rbx,%rbp
  40441e:	75 e0                	jne    404400 <_Z23FastUpdateExampleTimersv+0x4c0>
				if (*a->m_typedata != entity_lerp_fast::type) {
					a->Update(t);
				}
			}
			// fast loop with no virtual functions and maybe a different data format. 
			entity_lerp_fast::UpdateAll(t);
  404420:	f3 0f 10 44 24 0c    	movss  0xc(%rsp),%xmm0
  404426:	e8 35 e9 ff ff       	callq  402d60 <_ZN16entity_lerp_fast9UpdateAllEf>


	{
		// change styles for document 
		mytimer timer;
		for (float t = 0.0f; t < 1.0; t += 0.05f) {
  40442b:	f3 0f 10 35 95 14 00 	movss  0x1495(%rip),%xmm6        # 4058c8 <_ZN14entity_hermite4typeE+0xb8>
  404432:	00 
  404433:	41 83 ed 01          	sub    $0x1,%r13d
  404437:	f3 0f 58 74 24 0c    	addss  0xc(%rsp),%xmm6
  40443d:	f3 0f 11 74 24 0c    	movss  %xmm6,0xc(%rsp)
  404443:	75 a3                	jne    4043e8 <_Z23FastUpdateExampleTimersv+0x4a8>
	{
		m_start = std::chrono::high_resolution_clock::now();
	}
	std::chrono::duration<double> stop()
	{
		m_end = std::chrono::high_resolution_clock::now();
  404445:	e8 46 e1 ff ff       	callq  402590 <_ZNSt6chrono3_V212system_clock3nowEv@plt>
		const duration<_Rep2, _Period2>& __rhs)
      {
	typedef duration<_Rep1, _Period1>			__dur1;
	typedef duration<_Rep2, _Period2>			__dur2;
	typedef typename common_type<__dur1,__dur2>::type	__cd;
	return __cd(__cd(__lhs).count() - __cd(__rhs).count());
  40444a:	4c 29 f0             	sub    %r14,%rax
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(
	      static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));
  40444d:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  404452:	48 8b 05 8f 2e 20 00 	mov    0x202e8f(%rip),%rax        # 6072e8 <gFastUpdateExampleTimers+0x8>
  404459:	48 3b 05 90 2e 20 00 	cmp    0x202e90(%rip),%rax        # 6072f0 <gFastUpdateExampleTimers+0x10>
  404460:	f2 0f 5e 05 58 14 00 	divsd  0x1458(%rip),%xmm0        # 4058c0 <_ZN14entity_hermite4typeE+0xb0>
  404467:	00 
				}
			}
			// fast loop with no virtual functions and maybe a different data format. 
			entity_lerp_fast::UpdateAll(t);
		}
		gFastUpdateExampleTimers.emplace_back(timer.stop());
  404468:	f2 0f 11 44 24 20    	movsd  %xmm0,0x20(%rsp)
  40446e:	74 79                	je     4044e9 <_Z23FastUpdateExampleTimersv+0x5a9>
  404470:	48 85 c0             	test   %rax,%rax
  404473:	74 0c                	je     404481 <_Z23FastUpdateExampleTimersv+0x541>
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(
	      static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));
  404475:	f2 0f 59 05 3b 14 00 	mulsd  0x143b(%rip),%xmm0        # 4058b8 <_ZN14entity_hermite4typeE+0xa8>
  40447c:	00 
	template<typename _Rep2, typename _Period2, typename = typename
	       enable_if<treat_as_floating_point<rep>::value
			 || (ratio_divide<_Period2, period>::den == 1
			     && !treat_as_floating_point<_Rep2>::value)>::type>
	  constexpr duration(const duration<_Rep2, _Period2>& __d)
	  : __r(duration_cast<duration>(__d).count()) { }
  40447d:	f2 0f 11 00          	movsd  %xmm0,(%rax)
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }
  404481:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
  404486:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  40448b:	48 83 c0 08          	add    $0x8,%rax
  40448f:	48 89 05 52 2e 20 00 	mov    %rax,0x202e52(%rip)        # 6072e8 <gFastUpdateExampleTimers+0x8>
  404496:	48 39 dd             	cmp    %rbx,%rbp
  404499:	74 6c                	je     404507 <_Z23FastUpdateExampleTimersv+0x5c7>
  40449b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  4044a0:	48 8b 3b             	mov    (%rbx),%rdi
  4044a3:	48 85 ff             	test   %rdi,%rdi
  4044a6:	74 06                	je     4044ae <_Z23FastUpdateExampleTimersv+0x56e>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  4044a8:	48 8b 07             	mov    (%rdi),%rax
  4044ab:	ff 50 18             	callq  *0x18(%rax)
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
	  get_deleter()(__ptr);
	__ptr = pointer();
  4044ae:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
  4044b5:	48 83 c3 08          	add    $0x8,%rbx
  4044b9:	48 39 dd             	cmp    %rbx,%rbp
  4044bc:	75 e2                	jne    4044a0 <_Z23FastUpdateExampleTimersv+0x560>
  4044be:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  4044c3:	48 85 ff             	test   %rdi,%rdi
  4044c6:	74 05                	je     4044cd <_Z23FastUpdateExampleTimersv+0x58d>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  4044c8:	e8 83 e0 ff ff       	callq  402550 <_ZdlPv@plt>
      }
#endif

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  4044cd:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  4044d2:	48 85 ff             	test   %rdi,%rdi
  4044d5:	74 05                	je     4044dc <_Z23FastUpdateExampleTimersv+0x59c>
  4044d7:	e8 74 e0 ff ff       	callq  402550 <_ZdlPv@plt>
	}
}
  4044dc:	48 83 c4 70          	add    $0x70,%rsp
  4044e0:	5b                   	pop    %rbx
  4044e1:	5d                   	pop    %rbp
  4044e2:	41 5c                	pop    %r12
  4044e4:	41 5d                	pop    %r13
  4044e6:	41 5e                	pop    %r14
  4044e8:	c3                   	retq   
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  4044e9:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  4044ee:	bf e0 72 60 00       	mov    $0x6072e0,%edi
  4044f3:	e8 28 0e 00 00       	callq  405320 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EE19_M_emplace_back_auxIINS1_IdS2_ILl1ELl1EEEEEEEvDpOT_>
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }
  4044f8:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
  4044fd:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
  404502:	48 39 dd             	cmp    %rbx,%rbp
  404505:	75 99                	jne    4044a0 <_Z23FastUpdateExampleTimersv+0x560>
  404507:	48 89 ef             	mov    %rbp,%rdi
  40450a:	eb b7                	jmp    4044c3 <_Z23FastUpdateExampleTimersv+0x583>
  40450c:	48 89 c3             	mov    %rax,%rbx
      }
#endif

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  40450f:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  404514:	48 85 ff             	test   %rdi,%rdi
  404517:	74 05                	je     40451e <_Z23FastUpdateExampleTimersv+0x5de>
  404519:	e8 32 e0 ff ff       	callq  402550 <_ZdlPv@plt>
  40451e:	48 89 df             	mov    %rbx,%rdi
  404521:	e8 0a e1 ff ff       	callq  402630 <_Unwind_Resume@plt>

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  404526:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  40452b:	48 89 c3             	mov    %rax,%rbx
  40452e:	48 85 ff             	test   %rdi,%rdi
  404531:	74 06                	je     404539 <_Z23FastUpdateExampleTimersv+0x5f9>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  404533:	48 8b 07             	mov    (%rdi),%rax
  404536:	ff 50 18             	callq  *0x18(%rax)
		create_types.emplace_back(entity_hermite::type);
	}

	shuffle(create_types.begin(), create_types.end(), generator);

	vector<unique_ptr<entity>> entity_vec;
  404539:	4c 89 ef             	mov    %r13,%rdi
  40453c:	e8 5f 06 00 00       	callq  404ba0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EED1Ev>
  404541:	eb cc                	jmp    40450f <_Z23FastUpdateExampleTimersv+0x5cf>
  404543:	eb e1                	jmp    404526 <_Z23FastUpdateExampleTimersv+0x5e6>
  404545:	48 89 c3             	mov    %rax,%rbx
  404548:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  40454d:	0f 1f 00             	nopl   (%rax)
  404550:	eb e7                	jmp    404539 <_Z23FastUpdateExampleTimersv+0x5f9>
  404552:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  404559:	1f 84 00 00 00 00 00 

0000000000404560 <_Z28SlowComplicatedUpdateExamplev>:
		gSlowSimpleUpdateExampleTimers.emplace_back(timer.stop());
	}
}

void SlowComplicatedUpdateExample()
{
  404560:	41 55                	push   %r13
	pointer _M_start;
	pointer _M_finish;
	pointer _M_end_of_storage;

	_Vector_impl()
	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
  404562:	31 d2                	xor    %edx,%edx
  404564:	31 c0                	xor    %eax,%eax
  404566:	41 54                	push   %r12
  404568:	55                   	push   %rbp
  404569:	53                   	push   %rbx
  40456a:	bb 90 01 00 00       	mov    $0x190,%ebx
  40456f:	48 83 ec 78          	sub    $0x78,%rsp

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  404573:	48 8b 2d 7e 11 00 00 	mov    0x117e(%rip),%rbp        # 4056f8 <_ZN16entity_lerp_fast4typeE>
    {
      if ((__detail::__mod<_UIntType, __m>(__c) == 0)
	  && (__detail::__mod<_UIntType, __m>(__s) == 0))
	_M_x = 1;
      else
	_M_x = __detail::__mod<_UIntType, __m>(__s);
  40457a:	48 c7 44 24 10 01 00 	movq   $0x1,0x10(%rsp)
  404581:	00 00 
  404583:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
  40458a:	00 00 
  40458c:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
  404593:	00 00 
  404595:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
  40459c:	00 00 
  40459e:	eb 16                	jmp    4045b6 <_Z28SlowComplicatedUpdateExamplev+0x56>
  4045a0:	48 85 c0             	test   %rax,%rax
  4045a3:	74 03                	je     4045a8 <_Z28SlowComplicatedUpdateExamplev+0x48>
  4045a5:	48 89 28             	mov    %rbp,(%rax)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  4045a8:	48 83 c0 08          	add    $0x8,%rax
	uniform_real_distribution<float> distribution(0, 1);

	int number_of_lerp = 400;
	int number_of_hermite = 1000;
	vector<long long> create_types;
	for (int i = 0; i < number_of_lerp; i++)
  4045ac:	83 eb 01             	sub    $0x1,%ebx
  4045af:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
  4045b4:	74 23                	je     4045d9 <_Z28SlowComplicatedUpdateExamplev+0x79>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  4045b6:	48 39 d0             	cmp    %rdx,%rax
  4045b9:	75 e5                	jne    4045a0 <_Z28SlowComplicatedUpdateExamplev+0x40>
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  4045bb:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  4045c0:	be f8 56 40 00       	mov    $0x4056f8,%esi
  4045c5:	e8 36 06 00 00       	callq  404c00 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_>
  4045ca:	83 eb 01             	sub    $0x1,%ebx
  4045cd:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
  4045d2:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  4045d7:	75 dd                	jne    4045b6 <_Z28SlowComplicatedUpdateExamplev+0x56>
  4045d9:	bb e8 03 00 00       	mov    $0x3e8,%ebx
  4045de:	48 8b 2d 2b 12 00 00 	mov    0x122b(%rip),%rbp        # 405810 <_ZN14entity_hermite4typeE>
  4045e5:	eb 2a                	jmp    404611 <_Z28SlowComplicatedUpdateExamplev+0xb1>
  4045e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4045ee:	00 00 
  4045f0:	48 85 c0             	test   %rax,%rax
  4045f3:	74 03                	je     4045f8 <_Z28SlowComplicatedUpdateExamplev+0x98>
  4045f5:	48 89 28             	mov    %rbp,(%rax)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  4045f8:	48 83 c0 08          	add    $0x8,%rax
	{
		create_types.emplace_back(entity_lerp_fast::type);
	}
	for (int i = 0; i < number_of_hermite; i++)
  4045fc:	83 eb 01             	sub    $0x1,%ebx
  4045ff:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
  404604:	48 89 c6             	mov    %rax,%rsi
  404607:	74 26                	je     40462f <_Z28SlowComplicatedUpdateExamplev+0xcf>
  404609:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  40460e:	48 89 f0             	mov    %rsi,%rax
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  404611:	48 39 d0             	cmp    %rdx,%rax
  404614:	75 da                	jne    4045f0 <_Z28SlowComplicatedUpdateExamplev+0x90>
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  404616:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  40461b:	be 10 58 40 00       	mov    $0x405810,%esi
  404620:	e8 db 05 00 00       	callq  404c00 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_>
  404625:	83 eb 01             	sub    $0x1,%ebx
  404628:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  40462d:	75 da                	jne    404609 <_Z28SlowComplicatedUpdateExamplev+0xa9>
	{
		create_types.emplace_back(entity_hermite::type);
	}

	shuffle(create_types.begin(), create_types.end(), generator);
  40462f:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
  404634:	48 8d 54 24 10       	lea    0x10(%rsp),%rdx
  404639:	e8 a2 09 00 00       	callq  404fe0 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_>
  40463e:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
  404643:	4c 8b 64 24 38       	mov    0x38(%rsp),%r12
  404648:	0f 57 d2             	xorps  %xmm2,%xmm2
  40464b:	48 c7 44 24 50 00 00 	movq   $0x0,0x50(%rsp)
  404652:	00 00 
  404654:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
  40465b:	00 00 
  40465d:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
  404664:	00 00 

	vector<unique_ptr<entity>> entity_vec;
	for (auto &create_type : create_types)
  404666:	4c 39 e3             	cmp    %r12,%rbx
  404669:	f3 0f 11 54 24 0c    	movss  %xmm2,0xc(%rsp)
  40466f:	0f 84 7c 03 00 00    	je     4049f1 <_Z28SlowComplicatedUpdateExamplev+0x491>
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
	  if (__m)
	    __res %= __m;
  404675:	48 bd 05 00 00 00 02 	movabs $0x200000005,%rbp
  40467c:	00 00 00 
  40467f:	e9 08 01 00 00       	jmpq   40478c <_Z28SlowComplicatedUpdateExamplev+0x22c>
  404684:	0f 1f 40 00          	nopl   0x0(%rax)
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404688:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  40468d:	48 69 f0 a7 41 00 00 	imul   $0x41a7,%rax,%rsi
	  if (__m)
	    __res %= __m;
  404694:	48 89 f0             	mov    %rsi,%rax
  404697:	48 f7 e5             	mul    %rbp
  40469a:	48 89 f0             	mov    %rsi,%rax
  40469d:	48 29 d0             	sub    %rdx,%rax
  4046a0:	48 d1 e8             	shr    %rax
  4046a3:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  4046a7:	48 c1 e9 1e          	shr    $0x1e,%rcx
  4046ab:	48 89 c8             	mov    %rcx,%rax
  4046ae:	48 c1 e0 1f          	shl    $0x1f,%rax
  4046b2:	48 29 c8             	sub    %rcx,%rax
  4046b5:	48 89 f1             	mov    %rsi,%rcx
  4046b8:	48 29 c1             	sub    %rax,%rcx
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  4046bb:	48 69 f1 a7 41 00 00 	imul   $0x41a7,%rcx,%rsi
	  if (__m)
	    __res %= __m;
  4046c2:	48 89 f0             	mov    %rsi,%rax
  4046c5:	48 f7 e5             	mul    %rbp
  4046c8:	48 89 f0             	mov    %rsi,%rax
  4046cb:	48 29 d0             	sub    %rdx,%rax
  4046ce:	48 d1 e8             	shr    %rax
  4046d1:	48 01 c2             	add    %rax,%rdx
  4046d4:	48 c1 ea 1e          	shr    $0x1e,%rdx
  4046d8:	48 89 d0             	mov    %rdx,%rax
  4046db:	48 c1 e0 1f          	shl    $0x1f,%rax
  4046df:	48 29 d0             	sub    %rdx,%rax
  4046e2:	48 29 c6             	sub    %rax,%rsi
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  4046e5:	48 83 e9 01          	sub    $0x1,%rcx
  4046e9:	48 89 f2             	mov    %rsi,%rdx
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  4046ec:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  4046f1:	0f 88 59 02 00 00    	js     404950 <_Z28SlowComplicatedUpdateExamplev+0x3f0>
  4046f7:	f3 48 0f 2a c9       	cvtsi2ss %rcx,%xmm1
  4046fc:	f3 0f 10 64 24 0c    	movss  0xc(%rsp),%xmm4
  404702:	48 83 ea 01          	sub    $0x1,%rdx
  404706:	f3 0f 58 cc          	addss  %xmm4,%xmm1
	  __tmp *= __r;
	}
      return __sum / __tmp;
  40470a:	f3 0f 59 0d ba 11 00 	mulss  0x11ba(%rip),%xmm1        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  404711:	00 
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{
	  __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
	    __aurng(__urng);
	  return (__aurng() * (__p.b() - __p.a())) + __p.a();
  404712:	f3 0f 58 cc          	addss  %xmm4,%xmm1
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  404716:	0f 88 14 02 00 00    	js     404930 <_Z28SlowComplicatedUpdateExamplev+0x3d0>
  40471c:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  404721:	f3 0f 10 6c 24 0c    	movss  0xc(%rsp),%xmm5
  404727:	f3 0f 58 c5          	addss  %xmm5,%xmm0
	  __tmp *= __r;
	}
      return __sum / __tmp;
  40472b:	f3 0f 59 05 99 11 00 	mulss  0x1199(%rip),%xmm0        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  404732:	00 
  404733:	f3 0f 58 c5          	addss  %xmm5,%xmm0
			unique_ptr<entity> a(create_entity_hermite(distribution(generator), distribution(generator), distribution(generator), distribution(generator)));
			entity_vec.emplace_back(std::move(a));
		}
		else
		{
			unique_ptr<entity> a(create_entity_lerp_fast(distribution(generator), distribution(generator)));
  404737:	e8 84 e7 ff ff       	callq  402ec0 <_Z23create_entity_lerp_fastff>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  40473c:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  404741:	48 3b 54 24 60       	cmp    0x60(%rsp),%rdx
  404746:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  40474b:	0f 84 89 02 00 00    	je     4049da <_Z28SlowComplicatedUpdateExamplev+0x47a>
  404751:	48 85 d2             	test   %rdx,%rdx
  404754:	0f 84 10 02 00 00    	je     40496a <_Z28SlowComplicatedUpdateExamplev+0x40a>
      // Modifiers.
      pointer
      release() noexcept
      {
	pointer __p = get();
	std::get<0>(_M_t) = pointer();
  40475a:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
  404761:	00 00 
  404763:	48 89 02             	mov    %rax,(%rdx)
  404766:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  40476b:	48 83 c2 08          	add    $0x8,%rdx
  40476f:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  404774:	48 85 ff             	test   %rdi,%rdi
  404777:	74 06                	je     40477f <_Z28SlowComplicatedUpdateExamplev+0x21f>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  404779:	48 8b 07             	mov    (%rdi),%rax
  40477c:	ff 50 18             	callq  *0x18(%rax)
  40477f:	48 83 c3 08          	add    $0x8,%rbx
	}

	shuffle(create_types.begin(), create_types.end(), generator);

	vector<unique_ptr<entity>> entity_vec;
	for (auto &create_type : create_types)
  404783:	49 39 dc             	cmp    %rbx,%r12
  404786:	0f 84 65 02 00 00    	je     4049f1 <_Z28SlowComplicatedUpdateExamplev+0x491>
	{
		if (create_type == entity_hermite::type)
  40478c:	48 8b 05 7d 10 00 00 	mov    0x107d(%rip),%rax        # 405810 <_ZN14entity_hermite4typeE>
  404793:	48 39 03             	cmp    %rax,(%rbx)
  404796:	0f 85 ec fe ff ff    	jne    404688 <_Z28SlowComplicatedUpdateExamplev+0x128>
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  40479c:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  4047a1:	48 69 ca a7 41 00 00 	imul   $0x41a7,%rdx,%rcx
	  if (__m)
	    __res %= __m;
  4047a8:	48 89 c8             	mov    %rcx,%rax
  4047ab:	48 f7 e5             	mul    %rbp
  4047ae:	48 89 c8             	mov    %rcx,%rax
  4047b1:	48 29 d0             	sub    %rdx,%rax
  4047b4:	48 d1 e8             	shr    %rax
  4047b7:	48 8d 3c 02          	lea    (%rdx,%rax,1),%rdi
  4047bb:	48 c1 ef 1e          	shr    $0x1e,%rdi
  4047bf:	48 89 f8             	mov    %rdi,%rax
  4047c2:	48 c1 e0 1f          	shl    $0x1f,%rax
  4047c6:	48 29 f8             	sub    %rdi,%rax
  4047c9:	48 29 c1             	sub    %rax,%rcx
  4047cc:	48 89 cf             	mov    %rcx,%rdi
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  4047cf:	48 69 c9 a7 41 00 00 	imul   $0x41a7,%rcx,%rcx
	  if (__m)
	    __res %= __m;
  4047d6:	48 89 c8             	mov    %rcx,%rax
  4047d9:	48 f7 e5             	mul    %rbp
  4047dc:	48 89 c8             	mov    %rcx,%rax
  4047df:	48 29 d0             	sub    %rdx,%rax
  4047e2:	48 d1 e8             	shr    %rax
  4047e5:	48 8d 34 02          	lea    (%rdx,%rax,1),%rsi
  4047e9:	48 c1 ee 1e          	shr    $0x1e,%rsi
  4047ed:	48 89 f0             	mov    %rsi,%rax
  4047f0:	48 c1 e0 1f          	shl    $0x1f,%rax
  4047f4:	48 29 f0             	sub    %rsi,%rax
  4047f7:	48 29 c1             	sub    %rax,%rcx
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  4047fa:	4c 69 c1 a7 41 00 00 	imul   $0x41a7,%rcx,%r8
	  if (__m)
	    __res %= __m;
  404801:	48 89 ce             	mov    %rcx,%rsi
  404804:	4c 89 c0             	mov    %r8,%rax
  404807:	48 f7 e5             	mul    %rbp
  40480a:	4c 89 c0             	mov    %r8,%rax
  40480d:	48 29 d0             	sub    %rdx,%rax
  404810:	48 d1 e8             	shr    %rax
  404813:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  404817:	48 c1 e9 1e          	shr    $0x1e,%rcx
  40481b:	48 89 c8             	mov    %rcx,%rax
  40481e:	48 c1 e0 1f          	shl    $0x1f,%rax
  404822:	48 29 c8             	sub    %rcx,%rax
  404825:	4c 89 c1             	mov    %r8,%rcx
  404828:	48 29 c1             	sub    %rax,%rcx
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  40482b:	4c 69 c1 a7 41 00 00 	imul   $0x41a7,%rcx,%r8
	  if (__m)
	    __res %= __m;
  404832:	4c 89 c0             	mov    %r8,%rax
  404835:	48 f7 e5             	mul    %rbp
  404838:	4c 89 c0             	mov    %r8,%rax
  40483b:	48 29 d0             	sub    %rdx,%rax
  40483e:	48 d1 e8             	shr    %rax
  404841:	48 01 c2             	add    %rax,%rdx
  404844:	48 c1 ea 1e          	shr    $0x1e,%rdx
  404848:	48 89 d0             	mov    %rdx,%rax
  40484b:	48 c1 e0 1f          	shl    $0x1f,%rax
  40484f:	48 29 d0             	sub    %rdx,%rax
  404852:	4c 89 c2             	mov    %r8,%rdx
  404855:	48 29 c2             	sub    %rax,%rdx
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  404858:	48 83 ef 01          	sub    $0x1,%rdi
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  40485c:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  404861:	0f 88 59 01 00 00    	js     4049c0 <_Z28SlowComplicatedUpdateExamplev+0x460>
  404867:	f3 48 0f 2a df       	cvtsi2ss %rdi,%xmm3
  40486c:	f3 0f 10 7c 24 0c    	movss  0xc(%rsp),%xmm7
  404872:	48 83 ee 01          	sub    $0x1,%rsi
  404876:	f3 0f 58 df          	addss  %xmm7,%xmm3
	  __tmp *= __r;
	}
      return __sum / __tmp;
  40487a:	f3 0f 59 1d 4a 10 00 	mulss  0x104a(%rip),%xmm3        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  404881:	00 
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{
	  __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
	    __aurng(__urng);
	  return (__aurng() * (__p.b() - __p.a())) + __p.a();
  404882:	f3 0f 58 df          	addss  %xmm7,%xmm3
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  404886:	0f 88 1a 01 00 00    	js     4049a6 <_Z28SlowComplicatedUpdateExamplev+0x446>
  40488c:	f3 48 0f 2a d6       	cvtsi2ss %rsi,%xmm2
  404891:	f3 0f 10 7c 24 0c    	movss  0xc(%rsp),%xmm7
  404897:	48 83 e9 01          	sub    $0x1,%rcx
  40489b:	f3 0f 58 d7          	addss  %xmm7,%xmm2
	  __tmp *= __r;
	}
      return __sum / __tmp;
  40489f:	f3 0f 59 15 25 10 00 	mulss  0x1025(%rip),%xmm2        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  4048a6:	00 
  4048a7:	f3 0f 58 d7          	addss  %xmm7,%xmm2
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  4048ab:	0f 88 db 00 00 00    	js     40498c <_Z28SlowComplicatedUpdateExamplev+0x42c>
  4048b1:	f3 48 0f 2a c9       	cvtsi2ss %rcx,%xmm1
  4048b6:	f3 0f 10 74 24 0c    	movss  0xc(%rsp),%xmm6
  4048bc:	48 83 ea 01          	sub    $0x1,%rdx
  4048c0:	f3 0f 58 ce          	addss  %xmm6,%xmm1
	  __tmp *= __r;
	}
      return __sum / __tmp;
  4048c4:	f3 0f 59 0d 00 10 00 	mulss  0x1000(%rip),%xmm1        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  4048cb:	00 
  4048cc:	f3 0f 58 ce          	addss  %xmm6,%xmm1
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  4048d0:	0f 88 9c 00 00 00    	js     404972 <_Z28SlowComplicatedUpdateExamplev+0x412>
  4048d6:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  4048db:	f3 0f 10 7c 24 0c    	movss  0xc(%rsp),%xmm7
  4048e1:	f3 0f 58 c7          	addss  %xmm7,%xmm0
	  __tmp *= __r;
	}
      return __sum / __tmp;
  4048e5:	f3 0f 59 05 df 0f 00 	mulss  0xfdf(%rip),%xmm0        # 4058cc <_ZN14entity_hermite4typeE+0xbc>
  4048ec:	00 
  4048ed:	f3 0f 58 c7          	addss  %xmm7,%xmm0
		{
			unique_ptr<entity> a(create_entity_hermite(distribution(generator), distribution(generator), distribution(generator), distribution(generator)));
  4048f1:	e8 da e8 ff ff       	callq  4031d0 <_Z21create_entity_hermiteffff>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  4048f6:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  4048fb:	48 3b 54 24 60       	cmp    0x60(%rsp),%rdx
  404900:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  404905:	0f 85 46 fe ff ff    	jne    404751 <_Z28SlowComplicatedUpdateExamplev+0x1f1>
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  40490b:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  404910:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  404915:	4c 89 ef             	mov    %r13,%rdi
  404918:	e8 a3 08 00 00       	callq  4051c0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_>
  40491d:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  404922:	e9 4d fe ff ff       	jmpq   404774 <_Z28SlowComplicatedUpdateExamplev+0x214>
  404927:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40492e:	00 00 
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
	{
	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
  404930:	48 89 d0             	mov    %rdx,%rax
  404933:	83 e2 01             	and    $0x1,%edx
  404936:	48 d1 e8             	shr    %rax
  404939:	48 09 d0             	or     %rdx,%rax
  40493c:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  404941:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  404945:	e9 d7 fd ff ff       	jmpq   404721 <_Z28SlowComplicatedUpdateExamplev+0x1c1>
  40494a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  404950:	48 89 c8             	mov    %rcx,%rax
  404953:	83 e1 01             	and    $0x1,%ecx
  404956:	48 d1 e8             	shr    %rax
  404959:	48 09 c8             	or     %rcx,%rax
  40495c:	f3 48 0f 2a c8       	cvtsi2ss %rax,%xmm1
  404961:	f3 0f 58 c9          	addss  %xmm1,%xmm1
  404965:	e9 92 fd ff ff       	jmpq   4046fc <_Z28SlowComplicatedUpdateExamplev+0x19c>
  40496a:	48 89 c7             	mov    %rax,%rdi
  40496d:	e9 f9 fd ff ff       	jmpq   40476b <_Z28SlowComplicatedUpdateExamplev+0x20b>
  404972:	48 89 d0             	mov    %rdx,%rax
  404975:	83 e2 01             	and    $0x1,%edx
  404978:	48 d1 e8             	shr    %rax
  40497b:	48 09 d0             	or     %rdx,%rax
  40497e:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  404983:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  404987:	e9 4f ff ff ff       	jmpq   4048db <_Z28SlowComplicatedUpdateExamplev+0x37b>
  40498c:	48 89 c8             	mov    %rcx,%rax
  40498f:	83 e1 01             	and    $0x1,%ecx
  404992:	48 d1 e8             	shr    %rax
  404995:	48 09 c8             	or     %rcx,%rax
  404998:	f3 48 0f 2a c8       	cvtsi2ss %rax,%xmm1
  40499d:	f3 0f 58 c9          	addss  %xmm1,%xmm1
  4049a1:	e9 10 ff ff ff       	jmpq   4048b6 <_Z28SlowComplicatedUpdateExamplev+0x356>
  4049a6:	48 89 f0             	mov    %rsi,%rax
  4049a9:	83 e6 01             	and    $0x1,%esi
  4049ac:	48 d1 e8             	shr    %rax
  4049af:	48 09 f0             	or     %rsi,%rax
  4049b2:	f3 48 0f 2a d0       	cvtsi2ss %rax,%xmm2
  4049b7:	f3 0f 58 d2          	addss  %xmm2,%xmm2
  4049bb:	e9 d1 fe ff ff       	jmpq   404891 <_Z28SlowComplicatedUpdateExamplev+0x331>
  4049c0:	48 89 f8             	mov    %rdi,%rax
  4049c3:	83 e7 01             	and    $0x1,%edi
  4049c6:	48 d1 e8             	shr    %rax
  4049c9:	48 09 f8             	or     %rdi,%rax
  4049cc:	f3 48 0f 2a d8       	cvtsi2ss %rax,%xmm3
  4049d1:	f3 0f 58 db          	addss  %xmm3,%xmm3
  4049d5:	e9 92 fe ff ff       	jmpq   40486c <_Z28SlowComplicatedUpdateExamplev+0x30c>
  4049da:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  4049df:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  4049e4:	4c 89 ef             	mov    %r13,%rdi
  4049e7:	e8 d4 07 00 00       	callq  4051c0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_>
  4049ec:	e9 2c ff ff ff       	jmpq   40491d <_Z28SlowComplicatedUpdateExamplev+0x3bd>
public:
	std::chrono::time_point<std::chrono::high_resolution_clock> m_start;
	std::chrono::time_point<std::chrono::high_resolution_clock> m_end;
	mytimer()
	{
		m_start = std::chrono::high_resolution_clock::now();
  4049f1:	e8 9a db ff ff       	callq  402590 <_ZNSt6chrono3_V212system_clock3nowEv@plt>
  4049f6:	41 bc 14 00 00 00    	mov    $0x14,%r12d
  4049fc:	49 89 c5             	mov    %rax,%r13
  4049ff:	90                   	nop
  404a00:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
  404a05:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx

	{
		// change styles for document 
		mytimer timer;
		for (float t = 0.0f; t < 1.0; t += 0.05f) {
			for (auto &a : entity_vec) {
  404a0a:	48 39 eb             	cmp    %rbp,%rbx
  404a0d:	74 2c                	je     404a3b <_Z28SlowComplicatedUpdateExamplev+0x4db>
  404a0f:	90                   	nop
	return get();
      }

      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
  404a10:	48 8b 3b             	mov    (%rbx),%rdi
				// if we have a fast loop for this object don't update
				// so in this case we on the hermite entity but not the lerp ones. 
				if (a->GetType() != entity_lerp_fast::type)	{
  404a13:	48 8b 17             	mov    (%rdi),%rdx
  404a16:	ff 52 08             	callq  *0x8(%rdx)
  404a19:	48 98                	cltq   
  404a1b:	48 3b 05 d6 0c 00 00 	cmp    0xcd6(%rip),%rax        # 4056f8 <_ZN16entity_lerp_fast4typeE>
  404a22:	74 0e                	je     404a32 <_Z28SlowComplicatedUpdateExamplev+0x4d2>
  404a24:	48 8b 3b             	mov    (%rbx),%rdi
					a->Update(t);
  404a27:	f3 0f 10 44 24 0c    	movss  0xc(%rsp),%xmm0
  404a2d:	48 8b 07             	mov    (%rdi),%rax
  404a30:	ff 10                	callq  *(%rax)
  404a32:	48 83 c3 08          	add    $0x8,%rbx

	{
		// change styles for document 
		mytimer timer;
		for (float t = 0.0f; t < 1.0; t += 0.05f) {
			for (auto &a : entity_vec) {
  404a36:	48 39 dd             	cmp    %rbx,%rbp
  404a39:	75 d5                	jne    404a10 <_Z28SlowComplicatedUpdateExamplev+0x4b0>
				if (a->GetType() != entity_lerp_fast::type)	{
					a->Update(t);
				}
			}
			// fast loop with no virtual functions and maybe a different data format. 
			entity_lerp_fast::UpdateAll(t);
  404a3b:	f3 0f 10 44 24 0c    	movss  0xc(%rsp),%xmm0
  404a41:	e8 1a e3 ff ff       	callq  402d60 <_ZN16entity_lerp_fast9UpdateAllEf>


	{
		// change styles for document 
		mytimer timer;
		for (float t = 0.0f; t < 1.0; t += 0.05f) {
  404a46:	f3 0f 10 35 7a 0e 00 	movss  0xe7a(%rip),%xmm6        # 4058c8 <_ZN14entity_hermite4typeE+0xb8>
  404a4d:	00 
  404a4e:	41 83 ec 01          	sub    $0x1,%r12d
  404a52:	f3 0f 58 74 24 0c    	addss  0xc(%rsp),%xmm6
  404a58:	f3 0f 11 74 24 0c    	movss  %xmm6,0xc(%rsp)
  404a5e:	75 a0                	jne    404a00 <_Z28SlowComplicatedUpdateExamplev+0x4a0>
	{
		m_start = std::chrono::high_resolution_clock::now();
	}
	std::chrono::duration<double> stop()
	{
		m_end = std::chrono::high_resolution_clock::now();
  404a60:	e8 2b db ff ff       	callq  402590 <_ZNSt6chrono3_V212system_clock3nowEv@plt>
		const duration<_Rep2, _Period2>& __rhs)
      {
	typedef duration<_Rep1, _Period1>			__dur1;
	typedef duration<_Rep2, _Period2>			__dur2;
	typedef typename common_type<__dur1,__dur2>::type	__cd;
	return __cd(__cd(__lhs).count() - __cd(__rhs).count());
  404a65:	4c 29 e8             	sub    %r13,%rax
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(
	      static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));
  404a68:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  404a6d:	48 8b 05 94 28 20 00 	mov    0x202894(%rip),%rax        # 607308 <gSlowComplicatedUpdateExampleTimers+0x8>
  404a74:	48 3b 05 95 28 20 00 	cmp    0x202895(%rip),%rax        # 607310 <gSlowComplicatedUpdateExampleTimers+0x10>
  404a7b:	f2 0f 5e 05 3d 0e 00 	divsd  0xe3d(%rip),%xmm0        # 4058c0 <_ZN14entity_hermite4typeE+0xb0>
  404a82:	00 
				}
			}
			// fast loop with no virtual functions and maybe a different data format. 
			entity_lerp_fast::UpdateAll(t);
		}
		gSlowComplicatedUpdateExampleTimers.emplace_back(timer.stop());
  404a83:	f2 0f 11 44 24 20    	movsd  %xmm0,0x20(%rsp)
  404a89:	74 7c                	je     404b07 <_Z28SlowComplicatedUpdateExamplev+0x5a7>
  404a8b:	48 85 c0             	test   %rax,%rax
  404a8e:	74 0c                	je     404a9c <_Z28SlowComplicatedUpdateExamplev+0x53c>
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(
	      static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));
  404a90:	f2 0f 59 05 20 0e 00 	mulsd  0xe20(%rip),%xmm0        # 4058b8 <_ZN14entity_hermite4typeE+0xa8>
  404a97:	00 
	template<typename _Rep2, typename _Period2, typename = typename
	       enable_if<treat_as_floating_point<rep>::value
			 || (ratio_divide<_Period2, period>::den == 1
			     && !treat_as_floating_point<_Rep2>::value)>::type>
	  constexpr duration(const duration<_Rep2, _Period2>& __d)
	  : __r(duration_cast<duration>(__d).count()) { }
  404a98:	f2 0f 11 00          	movsd  %xmm0,(%rax)
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }
  404a9c:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
  404aa1:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
  404aa6:	48 83 c0 08          	add    $0x8,%rax
  404aaa:	48 89 05 57 28 20 00 	mov    %rax,0x202857(%rip)        # 607308 <gSlowComplicatedUpdateExampleTimers+0x8>
  404ab1:	48 39 dd             	cmp    %rbx,%rbp
  404ab4:	74 6f                	je     404b25 <_Z28SlowComplicatedUpdateExamplev+0x5c5>
  404ab6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  404abd:	00 00 00 

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  404ac0:	48 8b 3b             	mov    (%rbx),%rdi
  404ac3:	48 85 ff             	test   %rdi,%rdi
  404ac6:	74 06                	je     404ace <_Z28SlowComplicatedUpdateExamplev+0x56e>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  404ac8:	48 8b 07             	mov    (%rdi),%rax
  404acb:	ff 50 18             	callq  *0x18(%rax)
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
	  get_deleter()(__ptr);
	__ptr = pointer();
  404ace:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
  404ad5:	48 83 c3 08          	add    $0x8,%rbx
  404ad9:	48 39 dd             	cmp    %rbx,%rbp
  404adc:	75 e2                	jne    404ac0 <_Z28SlowComplicatedUpdateExamplev+0x560>
  404ade:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  404ae3:	48 85 ff             	test   %rdi,%rdi
  404ae6:	74 05                	je     404aed <_Z28SlowComplicatedUpdateExamplev+0x58d>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  404ae8:	e8 63 da ff ff       	callq  402550 <_ZdlPv@plt>
      }
#endif

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  404aed:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  404af2:	48 85 ff             	test   %rdi,%rdi
  404af5:	74 05                	je     404afc <_Z28SlowComplicatedUpdateExamplev+0x59c>
  404af7:	e8 54 da ff ff       	callq  402550 <_ZdlPv@plt>
	}
}
  404afc:	48 83 c4 78          	add    $0x78,%rsp
  404b00:	5b                   	pop    %rbx
  404b01:	5d                   	pop    %rbp
  404b02:	41 5c                	pop    %r12
  404b04:	41 5d                	pop    %r13
  404b06:	c3                   	retq   
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
  404b07:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  404b0c:	bf 00 73 60 00       	mov    $0x607300,%edi
  404b11:	e8 0a 08 00 00       	callq  405320 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EE19_M_emplace_back_auxIINS1_IdS2_ILl1ELl1EEEEEEEvDpOT_>
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }
  404b16:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
  404b1b:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
  404b20:	48 39 dd             	cmp    %rbx,%rbp
  404b23:	75 9b                	jne    404ac0 <_Z28SlowComplicatedUpdateExamplev+0x560>
  404b25:	48 89 ef             	mov    %rbp,%rdi
  404b28:	eb b9                	jmp    404ae3 <_Z28SlowComplicatedUpdateExamplev+0x583>
  404b2a:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  404b2f:	48 89 c3             	mov    %rax,%rbx
		create_types.emplace_back(entity_hermite::type);
	}

	shuffle(create_types.begin(), create_types.end(), generator);

	vector<unique_ptr<entity>> entity_vec;
  404b32:	4c 89 ef             	mov    %r13,%rdi
  404b35:	e8 66 00 00 00       	callq  404ba0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EED1Ev>
      }
#endif

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  404b3a:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  404b3f:	48 85 ff             	test   %rdi,%rdi
  404b42:	74 05                	je     404b49 <_Z28SlowComplicatedUpdateExamplev+0x5e9>
  404b44:	e8 07 da ff ff       	callq  402550 <_ZdlPv@plt>
  404b49:	48 89 df             	mov    %rbx,%rdi
  404b4c:	e8 df da ff ff       	callq  402630 <_Unwind_Resume@plt>

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  404b51:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  404b56:	48 89 c3             	mov    %rax,%rbx
  404b59:	48 85 ff             	test   %rdi,%rdi
  404b5c:	74 d4                	je     404b32 <_Z28SlowComplicatedUpdateExamplev+0x5d2>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  404b5e:	48 8b 07             	mov    (%rdi),%rax
  404b61:	ff 50 18             	callq  *0x18(%rax)
  404b64:	eb cc                	jmp    404b32 <_Z28SlowComplicatedUpdateExamplev+0x5d2>
  404b66:	eb e9                	jmp    404b51 <_Z28SlowComplicatedUpdateExamplev+0x5f1>
  404b68:	48 89 c3             	mov    %rax,%rbx
  404b6b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  404b70:	eb c8                	jmp    404b3a <_Z28SlowComplicatedUpdateExamplev+0x5da>
  404b72:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  404b79:	00 00 00 
  404b7c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000404b80 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EED1Ev>:
      }
#endif

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
  404b80:	48 8b 3f             	mov    (%rdi),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  404b83:	48 85 ff             	test   %rdi,%rdi
  404b86:	74 08                	je     404b90 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EED1Ev+0x10>
  404b88:	e9 c3 d9 ff ff       	jmpq   402550 <_ZdlPv@plt>
  404b8d:	0f 1f 00             	nopl   (%rax)
  404b90:	f3 c3                	repz retq 
  404b92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  404b99:	00 00 00 
  404b9c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000404ba0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EED1Ev>:
       *  The dtor only erases the elements, and note that if the
       *  elements themselves are pointers, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
  404ba0:	41 54                	push   %r12
  404ba2:	49 89 fc             	mov    %rdi,%r12
  404ba5:	55                   	push   %rbp
  404ba6:	53                   	push   %rbx
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }
  404ba7:	48 8b 6f 08          	mov    0x8(%rdi),%rbp
  404bab:	48 8b 1f             	mov    (%rdi),%rbx
  404bae:	48 39 dd             	cmp    %rbx,%rbp
  404bb1:	74 42                	je     404bf5 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EED1Ev+0x55>
  404bb3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  404bb8:	48 8b 3b             	mov    (%rbx),%rdi
  404bbb:	48 85 ff             	test   %rdi,%rdi
  404bbe:	74 06                	je     404bc6 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EED1Ev+0x26>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  404bc0:	48 8b 17             	mov    (%rdi),%rdx
  404bc3:	ff 52 18             	callq  *0x18(%rdx)
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
	  get_deleter()(__ptr);
	__ptr = pointer();
  404bc6:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
  404bcd:	48 83 c3 08          	add    $0x8,%rbx
  404bd1:	48 39 dd             	cmp    %rbx,%rbp
  404bd4:	75 e2                	jne    404bb8 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EED1Ev+0x18>
  404bd6:	49 8b 3c 24          	mov    (%r12),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  404bda:	48 85 ff             	test   %rdi,%rdi
  404bdd:	74 11                	je     404bf0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EED1Ev+0x50>
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }
  404bdf:	5b                   	pop    %rbx
  404be0:	5d                   	pop    %rbp
  404be1:	41 5c                	pop    %r12
  404be3:	e9 68 d9 ff ff       	jmpq   402550 <_ZdlPv@plt>
  404be8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  404bef:	00 
  404bf0:	5b                   	pop    %rbx
  404bf1:	5d                   	pop    %rbp
  404bf2:	41 5c                	pop    %r12
  404bf4:	c3                   	retq   
  404bf5:	48 89 ef             	mov    %rbp,%rdi
  404bf8:	eb e0                	jmp    404bda <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EED1Ev+0x3a>
  404bfa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000404c00 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_>:

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
  404c00:	41 55                	push   %r13
  404c02:	41 54                	push   %r12
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
  404c04:	41 bc 08 00 00 00    	mov    $0x8,%r12d
  404c0a:	55                   	push   %rbp
  404c0b:	53                   	push   %rbx
  404c0c:	48 89 fb             	mov    %rdi,%rbx
  404c0f:	48 83 ec 18          	sub    $0x18,%rsp

      // [23.2.4.2] capacity
      /**  Returns the number of elements in the %vector.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
  404c13:	48 8b 57 08          	mov    0x8(%rdi),%rdx
  404c17:	48 2b 17             	sub    (%rdi),%rdx
  404c1a:	48 c1 fa 03          	sar    $0x3,%rdx
  404c1e:	48 85 d2             	test   %rdx,%rdx
  404c21:	75 7d                	jne    404ca0 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_+0xa0>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  404c23:	4c 89 e7             	mov    %r12,%rdi
  404c26:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  404c2b:	e8 f0 d9 ff ff       	callq  402620 <_Znwm@plt>
  404c30:	48 8b 0b             	mov    (%rbx),%rcx
  404c33:	48 89 c5             	mov    %rax,%rbp
  404c36:	48 8b 43 08          	mov    0x8(%rbx),%rax

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  404c3a:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  404c3f:	49 89 ed             	mov    %rbp,%r13
  404c42:	48 29 c8             	sub    %rcx,%rax
  404c45:	48 c1 f8 03          	sar    $0x3,%rax
  404c49:	48 8b 36             	mov    (%rsi),%rsi
	pointer __new_start(this->_M_allocate(__len));
	pointer __new_finish(__new_start);
	__try
	  {
	    _Alloc_traits::construct(this->_M_impl, __new_start + size(),
				     std::forward<_Args>(__args)...);
  404c4c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  404c53:	00 
  404c54:	49 01 d5             	add    %rdx,%r13
  404c57:	74 04                	je     404c5d <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_+0x5d>
  404c59:	49 89 75 00          	mov    %rsi,0x0(%r13)
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
	  const ptrdiff_t _Num = __last - __first;
	  if (_Num)
  404c5d:	48 85 c0             	test   %rax,%rax
  404c60:	48 89 cf             	mov    %rcx,%rdi
  404c63:	74 0e                	je     404c73 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_+0x73>
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
  404c65:	48 89 ef             	mov    %rbp,%rdi
  404c68:	48 89 ce             	mov    %rcx,%rsi
  404c6b:	e8 70 d9 ff ff       	callq  4025e0 <memmove@plt>
  404c70:	48 8b 3b             	mov    (%rbx),%rdi
	    __new_finish
	      = std::__uninitialized_move_if_noexcept_a
	      (this->_M_impl._M_start, this->_M_impl._M_finish,
	       __new_start, _M_get_Tp_allocator());

	    ++__new_finish;
  404c73:	49 83 c5 08          	add    $0x8,%r13
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  404c77:	48 85 ff             	test   %rdi,%rdi
  404c7a:	74 05                	je     404c81 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_+0x81>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  404c7c:	e8 cf d8 ff ff       	callq  402550 <_ZdlPv@plt>
	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator());
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
  404c81:	48 89 2b             	mov    %rbp,(%rbx)
	this->_M_impl._M_finish = __new_finish;
	this->_M_impl._M_end_of_storage = __new_start + __len;
  404c84:	4c 01 e5             	add    %r12,%rbp
		      _M_get_Tp_allocator());
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
	this->_M_impl._M_finish = __new_finish;
  404c87:	4c 89 6b 08          	mov    %r13,0x8(%rbx)
	this->_M_impl._M_end_of_storage = __new_start + __len;
  404c8b:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
      }
  404c8f:	48 83 c4 18          	add    $0x18,%rsp
  404c93:	5b                   	pop    %rbx
  404c94:	5d                   	pop    %rbp
  404c95:	41 5c                	pop    %r12
  404c97:	41 5d                	pop    %r13
  404c99:	c3                   	retq   
  404c9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      _M_check_len(size_type __n, const char* __s) const
      {
	if (max_size() - size() < __n)
	  __throw_length_error(__N(__s));

	const size_type __len = size() + std::max(size(), __n);
  404ca0:	48 8d 04 12          	lea    (%rdx,%rdx,1),%rax
	return (__len < size() || __len > max_size()) ? max_size() : __len;
  404ca4:	48 39 c2             	cmp    %rax,%rdx
  404ca7:	76 0c                	jbe    404cb5 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_+0xb5>
  404ca9:	49 c7 c4 f8 ff ff ff 	mov    $0xfffffffffffffff8,%r12
  404cb0:	e9 6e ff ff ff       	jmpq   404c23 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_+0x23>
  404cb5:	48 b9 ff ff ff ff ff 	movabs $0x1fffffffffffffff,%rcx
  404cbc:	ff ff 1f 
  404cbf:	48 c1 e2 04          	shl    $0x4,%rdx
  404cc3:	49 c7 c4 f8 ff ff ff 	mov    $0xfffffffffffffff8,%r12
  404cca:	48 39 c8             	cmp    %rcx,%rax
  404ccd:	4c 0f 46 e2          	cmovbe %rdx,%r12
  404cd1:	e9 4d ff ff ff       	jmpq   404c23 <_ZNSt6vectorIxSaIxEE19_M_emplace_back_auxIIRKxEEEvDpOT_+0x23>
  404cd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  404cdd:	00 00 00 

0000000000404ce0 <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE>:


  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
  404ce0:	41 57                	push   %r15
  404ce2:	41 56                	push   %r14
  404ce4:	41 55                	push   %r13
  404ce6:	41 54                	push   %r12
  404ce8:	55                   	push   %rbp
  404ce9:	53                   	push   %rbx
      operator()(_UniformRandomNumberGenerator& __urng,
		 const param_type& __param)
  404cea:	4c 8b 22             	mov    (%rdx),%r12

	const __uctype __urngmin = __urng.min();
	const __uctype __urngmax = __urng.max();
	const __uctype __urngrange = __urngmax - __urngmin;
	const __uctype __urange
	  = __uctype(__param.b()) - __uctype(__param.a());
  404ced:	48 8b 7a 08          	mov    0x8(%rdx),%rdi
  404cf1:	4c 29 e7             	sub    %r12,%rdi

	__uctype __ret;

	if (__urngrange > __urange)
  404cf4:	48 81 ff fc ff ff 7f 	cmp    $0x7ffffffc,%rdi
  404cfb:	77 73                	ja     404d70 <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x90>
	  {
	    // downscaling
	    const __uctype __uerange = __urange + 1; // __urange can be zero
  404cfd:	48 83 c7 01          	add    $0x1,%rdi
	    const __uctype __scaling = __urngrange / __uerange;
  404d01:	b8 fd ff ff 7f       	mov    $0x7ffffffd,%eax
  404d06:	31 d2                	xor    %edx,%edx
  404d08:	48 f7 f7             	div    %rdi
  404d0b:	48 8b 0e             	mov    (%rsi),%rcx
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
	  if (__m)
	    __res %= __m;
  404d0e:	49 ba 05 00 00 00 02 	movabs $0x200000005,%r10
  404d15:	00 00 00 
	    const __uctype __past = __uerange * __scaling;
  404d18:	48 0f af f8          	imul   %rax,%rdi

	if (__urngrange > __urange)
	  {
	    // downscaling
	    const __uctype __uerange = __urange + 1; // __urange can be zero
	    const __uctype __scaling = __urngrange / __uerange;
  404d1c:	49 89 c0             	mov    %rax,%r8
  404d1f:	90                   	nop
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404d20:	4c 69 c9 a7 41 00 00 	imul   $0x41a7,%rcx,%r9
	  if (__m)
	    __res %= __m;
  404d27:	4c 89 c8             	mov    %r9,%rax
  404d2a:	49 f7 e2             	mul    %r10
  404d2d:	4c 89 c8             	mov    %r9,%rax
  404d30:	48 29 d0             	sub    %rdx,%rax
  404d33:	48 d1 e8             	shr    %rax
  404d36:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  404d3a:	48 c1 e9 1e          	shr    $0x1e,%rcx
  404d3e:	48 89 c8             	mov    %rcx,%rax
  404d41:	48 c1 e0 1f          	shl    $0x1f,%rax
  404d45:	48 29 c8             	sub    %rcx,%rax
  404d48:	4c 89 c9             	mov    %r9,%rcx
  404d4b:	48 29 c1             	sub    %rax,%rcx
	    const __uctype __past = __uerange * __scaling;
	    do
	      __ret = __uctype(__urng()) - __urngmin;
  404d4e:	48 8d 41 ff          	lea    -0x1(%rcx),%rax
	  {
	    // downscaling
	    const __uctype __uerange = __urange + 1; // __urange can be zero
	    const __uctype __scaling = __urngrange / __uerange;
	    const __uctype __past = __uerange * __scaling;
	    do
  404d52:	48 39 c7             	cmp    %rax,%rdi
  404d55:	76 c9                	jbe    404d20 <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x40>
	      __ret = __uctype(__urng()) - __urngmin;
	    while (__ret >= __past);
	    __ret /= __scaling;
  404d57:	31 d2                	xor    %edx,%edx
  404d59:	48 89 0e             	mov    %rcx,(%rsi)
  404d5c:	49 f7 f0             	div    %r8
	  }
	else
	  __ret = __uctype(__urng()) - __urngmin;

	return __ret + __param.a();
      }
  404d5f:	5b                   	pop    %rbx
  404d60:	5d                   	pop    %rbp
	    while (__ret > __urange || __ret < __tmp);
	  }
	else
	  __ret = __uctype(__urng()) - __urngmin;

	return __ret + __param.a();
  404d61:	4c 01 e0             	add    %r12,%rax
      }
  404d64:	41 5c                	pop    %r12
  404d66:	41 5d                	pop    %r13
  404d68:	41 5e                	pop    %r14
  404d6a:	41 5f                	pop    %r15
  404d6c:	c3                   	retq   
  404d6d:	0f 1f 00             	nopl   (%rax)
	    do
	      __ret = __uctype(__urng()) - __urngmin;
	    while (__ret >= __past);
	    __ret /= __scaling;
	  }
	else if (__urngrange < __urange)
  404d70:	48 81 ff fd ff ff 7f 	cmp    $0x7ffffffd,%rdi
  404d77:	0f 84 11 02 00 00    	je     404f8e <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x2ae>
  404d7d:	48 89 fa             	mov    %rdi,%rdx
  404d80:	49 b8 09 00 00 00 02 	movabs $0x8000000200000009,%r8
  404d87:	00 00 80 
  404d8a:	48 8b 0e             	mov    (%rsi),%rcx
  404d8d:	48 d1 ea             	shr    %rdx
  404d90:	41 ba fd ff ff 7f    	mov    $0x7ffffffd,%r10d
  404d96:	48 89 d0             	mov    %rdx,%rax
  404d99:	49 f7 e0             	mul    %r8
  404d9c:	49 89 d1             	mov    %rdx,%r9
  404d9f:	48 c1 ea 1e          	shr    $0x1e,%rdx
  404da3:	48 89 d0             	mov    %rdx,%rax
  404da6:	49 c1 e9 1d          	shr    $0x1d,%r9
  404daa:	49 f7 e0             	mul    %r8
	__uctype __ret;

	if (__urngrange > __urange)
	  {
	    // downscaling
	    const __uctype __uerange = __urange + 1; // __urange can be zero
  404dad:	4d 8d 59 01          	lea    0x1(%r9),%r11
  404db1:	49 b8 05 00 00 00 02 	movabs $0x200000005,%r8
  404db8:	00 00 00 
  404dbb:	4d 89 c6             	mov    %r8,%r14
  404dbe:	48 c1 ea 1d          	shr    $0x1d,%rdx
  404dc2:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
  404dc6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  404dcd:	00 00 00 
	const __uctype __urange
	  = __uctype(__param.b()) - __uctype(__param.a());

	__uctype __ret;

	if (__urngrange > __urange)
  404dd0:	49 81 f9 fc ff ff 7f 	cmp    $0x7ffffffc,%r9
  404dd7:	0f 87 bb 00 00 00    	ja     404e98 <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x1b8>
	  {
	    // downscaling
	    const __uctype __uerange = __urange + 1; // __urange can be zero
	    const __uctype __scaling = __urngrange / __uerange;
  404ddd:	4c 89 d0             	mov    %r10,%rax
  404de0:	31 d2                	xor    %edx,%edx
  404de2:	49 f7 f3             	div    %r11
	    const __uctype __past = __uerange * __scaling;
  404de5:	49 89 c5             	mov    %rax,%r13

	if (__urngrange > __urange)
	  {
	    // downscaling
	    const __uctype __uerange = __urange + 1; // __urange can be zero
	    const __uctype __scaling = __urngrange / __uerange;
  404de8:	48 89 c5             	mov    %rax,%rbp
	    const __uctype __past = __uerange * __scaling;
  404deb:	4d 0f af eb          	imul   %r11,%r13
  404def:	90                   	nop
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404df0:	4c 69 f9 a7 41 00 00 	imul   $0x41a7,%rcx,%r15
	  if (__m)
	    __res %= __m;
  404df7:	4c 89 f8             	mov    %r15,%rax
  404dfa:	49 f7 e0             	mul    %r8
  404dfd:	4c 89 f8             	mov    %r15,%rax
  404e00:	48 29 d0             	sub    %rdx,%rax
  404e03:	48 d1 e8             	shr    %rax
  404e06:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  404e0a:	48 c1 e9 1e          	shr    $0x1e,%rcx
  404e0e:	48 89 c8             	mov    %rcx,%rax
  404e11:	48 c1 e0 1f          	shl    $0x1f,%rax
  404e15:	48 29 c8             	sub    %rcx,%rax
  404e18:	4c 89 f9             	mov    %r15,%rcx
  404e1b:	48 29 c1             	sub    %rax,%rcx
	    do
	      __ret = __uctype(__urng()) - __urngmin;
  404e1e:	48 8d 41 ff          	lea    -0x1(%rcx),%rax
	  {
	    // downscaling
	    const __uctype __uerange = __urange + 1; // __urange can be zero
	    const __uctype __scaling = __urngrange / __uerange;
	    const __uctype __past = __uerange * __scaling;
	    do
  404e22:	49 39 c5             	cmp    %rax,%r13
  404e25:	76 c9                	jbe    404df0 <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x110>
	      __ret = __uctype(__urng()) - __urngmin;
	    while (__ret >= __past);
	    __ret /= __scaling;
  404e27:	31 d2                	xor    %edx,%edx
  404e29:	48 f7 f5             	div    %rbp
  404e2c:	48 89 ca             	mov    %rcx,%rdx
	    */
	    __uctype __tmp; // wraparound control
	    do
	      {
		const __uctype __uerngrange = __urngrange + 1;
		__tmp = (__uerngrange * operator()
  404e2f:	48 8d 0c 00          	lea    (%rax,%rax,1),%rcx
  404e33:	48 c1 e0 1f          	shl    $0x1f,%rax
  404e37:	48 89 c5             	mov    %rax,%rbp
  404e3a:	48 29 cd             	sub    %rcx,%rbp
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404e3d:	4c 69 ea a7 41 00 00 	imul   $0x41a7,%rdx,%r13
	  if (__m)
	    __res %= __m;
  404e44:	4c 89 e8             	mov    %r13,%rax
  404e47:	49 f7 e0             	mul    %r8
  404e4a:	4c 89 e8             	mov    %r13,%rax
  404e4d:	48 29 d0             	sub    %rdx,%rax
  404e50:	48 d1 e8             	shr    %rax
  404e53:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  404e57:	48 c1 e9 1e          	shr    $0x1e,%rcx
  404e5b:	48 89 c8             	mov    %rcx,%rax
  404e5e:	48 c1 e0 1f          	shl    $0x1f,%rax
  404e62:	48 29 c8             	sub    %rcx,%rax
  404e65:	4c 89 e9             	mov    %r13,%rcx
  404e68:	48 29 c1             	sub    %rax,%rcx
			 (__urng, param_type(0, __urange / __uerngrange)));
		__ret = __tmp + (__uctype(__urng()) - __urngmin);
  404e6b:	48 8d 44 29 ff       	lea    -0x1(%rcx,%rbp,1),%rax
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  404e70:	48 89 0e             	mov    %rcx,(%rsi)
	      and
	
	      low in [0, urngrange].
	    */
	    __uctype __tmp; // wraparound control
	    do
  404e73:	48 39 e8             	cmp    %rbp,%rax
  404e76:	0f 82 54 ff ff ff    	jb     404dd0 <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0xf0>
  404e7c:	48 39 f8             	cmp    %rdi,%rax
  404e7f:	0f 86 da fe ff ff    	jbe    404d5f <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x7f>
	const __uctype __urange
	  = __uctype(__param.b()) - __uctype(__param.a());

	__uctype __ret;

	if (__urngrange > __urange)
  404e85:	49 81 f9 fc ff ff 7f 	cmp    $0x7ffffffc,%r9
  404e8c:	0f 86 4b ff ff ff    	jbe    404ddd <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0xfd>
  404e92:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	    do
	      __ret = __uctype(__urng()) - __urngmin;
	    while (__ret >= __past);
	    __ret /= __scaling;
	  }
	else if (__urngrange < __urange)
  404e98:	49 81 f9 fd ff ff 7f 	cmp    $0x7ffffffd,%r9
  404e9f:	75 3f                	jne    404ee0 <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x200>
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404ea1:	48 69 c9 a7 41 00 00 	imul   $0x41a7,%rcx,%rcx
	  if (__m)
	    __res %= __m;
  404ea8:	48 89 c8             	mov    %rcx,%rax
  404eab:	49 f7 e0             	mul    %r8
  404eae:	48 89 c8             	mov    %rcx,%rax
  404eb1:	48 29 d0             	sub    %rdx,%rax
  404eb4:	48 d1 e8             	shr    %rax
  404eb7:	48 01 c2             	add    %rax,%rdx
  404eba:	48 c1 ea 1e          	shr    $0x1e,%rdx
  404ebe:	48 89 d0             	mov    %rdx,%rax
  404ec1:	48 c1 e0 1f          	shl    $0x1f,%rax
  404ec5:	48 29 d0             	sub    %rdx,%rax
  404ec8:	48 29 c1             	sub    %rax,%rcx
  404ecb:	48 89 ca             	mov    %rcx,%rdx
		__ret = __tmp + (__uctype(__urng()) - __urngmin);
	      }
	    while (__ret > __urange || __ret < __tmp);
	  }
	else
	  __ret = __uctype(__urng()) - __urngmin;
  404ece:	48 8d 41 ff          	lea    -0x1(%rcx),%rax
  404ed2:	e9 58 ff ff ff       	jmpq   404e2f <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x14f>
  404ed7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  404ede:	00 00 
  404ee0:	4c 89 d0             	mov    %r10,%rax
  404ee3:	31 d2                	xor    %edx,%edx
  404ee5:	48 f7 f3             	div    %rbx
  404ee8:	49 89 c5             	mov    %rax,%r13
  404eeb:	48 89 c5             	mov    %rax,%rbp
  404eee:	4c 0f af eb          	imul   %rbx,%r13
  404ef2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404ef8:	4c 69 f9 a7 41 00 00 	imul   $0x41a7,%rcx,%r15
	  if (__m)
	    __res %= __m;
  404eff:	4c 89 f8             	mov    %r15,%rax
  404f02:	49 f7 e0             	mul    %r8
  404f05:	4c 89 f8             	mov    %r15,%rax
  404f08:	48 29 d0             	sub    %rdx,%rax
  404f0b:	48 d1 e8             	shr    %rax
  404f0e:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  404f12:	48 c1 e9 1e          	shr    $0x1e,%rcx
  404f16:	48 89 c8             	mov    %rcx,%rax
  404f19:	48 c1 e0 1f          	shl    $0x1f,%rax
  404f1d:	48 29 c8             	sub    %rcx,%rax
  404f20:	4c 89 f9             	mov    %r15,%rcx
  404f23:	48 29 c1             	sub    %rax,%rcx
	    // downscaling
	    const __uctype __uerange = __urange + 1; // __urange can be zero
	    const __uctype __scaling = __urngrange / __uerange;
	    const __uctype __past = __uerange * __scaling;
	    do
	      __ret = __uctype(__urng()) - __urngmin;
  404f26:	48 8d 41 ff          	lea    -0x1(%rcx),%rax
	  {
	    // downscaling
	    const __uctype __uerange = __urange + 1; // __urange can be zero
	    const __uctype __scaling = __urngrange / __uerange;
	    const __uctype __past = __uerange * __scaling;
	    do
  404f2a:	4c 39 e8             	cmp    %r13,%rax
  404f2d:	73 c9                	jae    404ef8 <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x218>
	      __ret = __uctype(__urng()) - __urngmin;
	    while (__ret >= __past);
	    __ret /= __scaling;
  404f2f:	31 d2                	xor    %edx,%edx
  404f31:	48 f7 f5             	div    %rbp
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404f34:	48 69 c9 a7 41 00 00 	imul   $0x41a7,%rcx,%rcx
	    */
	    __uctype __tmp; // wraparound control
	    do
	      {
		const __uctype __uerngrange = __urngrange + 1;
		__tmp = (__uerngrange * operator()
  404f3b:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
  404f3f:	48 c1 e0 1f          	shl    $0x1f,%rax
  404f43:	49 89 c7             	mov    %rax,%r15
  404f46:	49 29 d7             	sub    %rdx,%r15
	  if (__m)
	    __res %= __m;
  404f49:	48 89 c8             	mov    %rcx,%rax
  404f4c:	49 f7 e6             	mul    %r14
  404f4f:	48 89 c8             	mov    %rcx,%rax
  404f52:	48 29 d0             	sub    %rdx,%rax
  404f55:	48 d1 e8             	shr    %rax
  404f58:	48 01 c2             	add    %rax,%rdx
  404f5b:	48 c1 ea 1e          	shr    $0x1e,%rdx
  404f5f:	48 89 d0             	mov    %rdx,%rax
  404f62:	48 c1 e0 1f          	shl    $0x1f,%rax
  404f66:	48 29 d0             	sub    %rdx,%rax
  404f69:	48 89 ca             	mov    %rcx,%rdx
  404f6c:	48 29 c2             	sub    %rax,%rdx
			 (__urng, param_type(0, __urange / __uerngrange)));
		__ret = __tmp + (__uctype(__urng()) - __urngmin);
  404f6f:	4a 8d 44 3a ff       	lea    -0x1(%rdx,%r15,1),%rax
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  404f74:	48 89 16             	mov    %rdx,(%rsi)
	      and
	
	      low in [0, urngrange].
	    */
	    __uctype __tmp; // wraparound control
	    do
  404f77:	49 39 c7             	cmp    %rax,%r15
  404f7a:	76 08                	jbe    404f84 <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x2a4>
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
	  if (__m)
	    __res %= __m;
  404f7c:	48 89 d1             	mov    %rdx,%rcx
  404f7f:	e9 74 ff ff ff       	jmpq   404ef8 <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x218>
  404f84:	4c 39 c8             	cmp    %r9,%rax
  404f87:	77 f3                	ja     404f7c <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x29c>
  404f89:	e9 a1 fe ff ff       	jmpq   404e2f <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE+0x14f>
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404f8e:	48 8b 06             	mov    (%rsi),%rax
	  if (__m)
	    __res %= __m;
  404f91:	48 ba 05 00 00 00 02 	movabs $0x200000005,%rdx
  404f98:	00 00 00 
	  }
	else
	  __ret = __uctype(__urng()) - __urngmin;

	return __ret + __param.a();
      }
  404f9b:	5b                   	pop    %rbx
  404f9c:	5d                   	pop    %rbp
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  404f9d:	48 69 c8 a7 41 00 00 	imul   $0x41a7,%rax,%rcx
	  if (__m)
	    __res %= __m;
  404fa4:	48 89 c8             	mov    %rcx,%rax
  404fa7:	48 f7 e2             	mul    %rdx
  404faa:	48 89 c8             	mov    %rcx,%rax
  404fad:	48 29 d0             	sub    %rdx,%rax
  404fb0:	48 d1 e8             	shr    %rax
  404fb3:	48 01 c2             	add    %rax,%rdx
  404fb6:	48 c1 ea 1e          	shr    $0x1e,%rdx
  404fba:	48 89 d0             	mov    %rdx,%rax
  404fbd:	48 c1 e0 1f          	shl    $0x1f,%rax
  404fc1:	48 29 d0             	sub    %rdx,%rax
  404fc4:	48 89 ca             	mov    %rcx,%rdx
  404fc7:	48 29 c2             	sub    %rax,%rdx
		__ret = __tmp + (__uctype(__urng()) - __urngmin);
	      }
	    while (__ret > __urange || __ret < __tmp);
	  }
	else
	  __ret = __uctype(__urng()) - __urngmin;
  404fca:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  404fce:	48 89 16             	mov    %rdx,(%rsi)

	return __ret + __param.a();
  404fd1:	4c 01 e0             	add    %r12,%rax
      }
  404fd4:	41 5c                	pop    %r12
  404fd6:	41 5d                	pop    %r13
  404fd8:	41 5e                	pop    %r14
  404fda:	41 5f                	pop    %r15
  404fdc:	c3                   	retq   
  404fdd:	0f 1f 00             	nopl   (%rax)

0000000000404fe0 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_>:
   *  provide random numbers.
  */
  template<typename _RandomAccessIterator,
	   typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
  404fe0:	41 57                	push   %r15
  404fe2:	41 56                	push   %r14
  404fe4:	41 55                	push   %r13
  404fe6:	41 54                	push   %r12
  404fe8:	55                   	push   %rbp
  404fe9:	48 89 fd             	mov    %rdi,%rbp
  404fec:	53                   	push   %rbx
  404fed:	48 83 ec 38          	sub    $0x38,%rsp
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);

      if (__first == __last)
  404ff1:	48 39 fe             	cmp    %rdi,%rsi
   *  provide random numbers.
  */
  template<typename _RandomAccessIterator,
	   typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
  404ff4:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);

      if (__first == __last)
  404ff9:	0f 84 c1 00 00 00    	je     4050c0 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_+0xe0>
  404fff:	48 8d 5f 08          	lea    0x8(%rdi),%rbx
	typedef uniform_int_distribution<_IntType> distribution_type;

	explicit
	param_type(_IntType __a = 0,
		   _IntType __b = std::numeric_limits<_IntType>::max())
	: _M_a(__a), _M_b(__b)
  405003:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
  40500a:	00 00 
  40500c:	48 c7 44 24 18 ff ff 	movq   $0xffffffffffffffff,0x18(%rsp)
  405013:	ff ff 
      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;
      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
  405015:	48 39 f3             	cmp    %rsi,%rbx
  405018:	0f 84 a2 00 00 00    	je     4050c0 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_+0xe0>
  40501e:	49 89 d4             	mov    %rdx,%r12
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
	  if (__m)
	    __res %= __m;
  405021:	49 bd 05 00 00 00 02 	movabs $0x200000005,%r13
  405028:	00 00 00 
  40502b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
	      const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }
  405030:	49 89 de             	mov    %rbx,%r14
  405033:	49 29 ee             	sub    %rbp,%r14
  405036:	49 c1 fe 03          	sar    $0x3,%r14
	const __uctype __urange
	  = __uctype(__param.b()) - __uctype(__param.a());

	__uctype __ret;

	if (__urngrange > __urange)
  40503a:	49 81 fe fc ff ff 7f 	cmp    $0x7ffffffc,%r14
  405041:	0f 87 89 00 00 00    	ja     4050d0 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_+0xf0>
	  {
	    // downscaling
	    const __uctype __uerange = __urange + 1; // __urange can be zero
  405047:	49 83 c6 01          	add    $0x1,%r14
	    const __uctype __scaling = __urngrange / __uerange;
  40504b:	b8 fd ff ff 7f       	mov    $0x7ffffffd,%eax
  405050:	31 d2                	xor    %edx,%edx
  405052:	49 f7 f6             	div    %r14
  405055:	49 8b 0c 24          	mov    (%r12),%rcx
	    const __uctype __past = __uerange * __scaling;
  405059:	4c 0f af f0          	imul   %rax,%r14

	if (__urngrange > __urange)
	  {
	    // downscaling
	    const __uctype __uerange = __urange + 1; // __urange can be zero
	    const __uctype __scaling = __urngrange / __uerange;
  40505d:	48 89 c7             	mov    %rax,%rdi
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  405060:	4c 69 c1 a7 41 00 00 	imul   $0x41a7,%rcx,%r8
	  if (__m)
	    __res %= __m;
  405067:	4c 89 c0             	mov    %r8,%rax
  40506a:	4c 89 c1             	mov    %r8,%rcx
  40506d:	49 f7 e5             	mul    %r13
  405070:	48 29 d1             	sub    %rdx,%rcx
  405073:	48 d1 e9             	shr    %rcx
  405076:	48 01 d1             	add    %rdx,%rcx
  405079:	48 c1 e9 1e          	shr    $0x1e,%rcx
  40507d:	48 89 ce             	mov    %rcx,%rsi
  405080:	48 c1 e6 1f          	shl    $0x1f,%rsi
  405084:	48 29 ce             	sub    %rcx,%rsi
  405087:	4c 89 c1             	mov    %r8,%rcx
  40508a:	48 29 f1             	sub    %rsi,%rcx
	    const __uctype __past = __uerange * __scaling;
	    do
	      __ret = __uctype(__urng()) - __urngmin;
  40508d:	48 8d 41 ff          	lea    -0x1(%rcx),%rax
	  {
	    // downscaling
	    const __uctype __uerange = __urange + 1; // __urange can be zero
	    const __uctype __scaling = __urngrange / __uerange;
	    const __uctype __past = __uerange * __scaling;
	    do
  405091:	49 39 c6             	cmp    %rax,%r14
  405094:	76 ca                	jbe    405060 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_+0x80>
	      __ret = __uctype(__urng()) - __urngmin;
	    while (__ret >= __past);
	    __ret /= __scaling;
  405096:	31 d2                	xor    %edx,%edx
  405098:	49 89 0c 24          	mov    %rcx,(%r12)
  40509c:	48 f7 f7             	div    %rdi
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }
  40509f:	48 8d 44 c5 00       	lea    0x0(%rbp,%rax,8),%rax
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
  4050a4:	48 8b 13             	mov    (%rbx),%rdx
  4050a7:	48 83 c3 08          	add    $0x8,%rbx
      __a = _GLIBCXX_MOVE(__b);
  4050ab:	48 8b 08             	mov    (%rax),%rcx
  4050ae:	48 89 4b f8          	mov    %rcx,-0x8(%rbx)
  4050b2:	48 39 5c 24 08       	cmp    %rbx,0x8(%rsp)
      __b = _GLIBCXX_MOVE(__tmp);
  4050b7:	48 89 10             	mov    %rdx,(%rax)
  4050ba:	0f 85 70 ff ff ff    	jne    405030 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_+0x50>
	std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }
  4050c0:	48 83 c4 38          	add    $0x38,%rsp
  4050c4:	5b                   	pop    %rbx
  4050c5:	5d                   	pop    %rbp
  4050c6:	41 5c                	pop    %r12
  4050c8:	41 5d                	pop    %r13
  4050ca:	41 5e                	pop    %r14
  4050cc:	41 5f                	pop    %r15
  4050ce:	c3                   	retq   
  4050cf:	90                   	nop
	  }
	else if (__urngrange < __urange)
  4050d0:	49 81 fe fd ff ff 7f 	cmp    $0x7ffffffd,%r14
  4050d7:	0f 84 9b 00 00 00    	je     405178 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_+0x198>
  4050dd:	4d 89 f7             	mov    %r14,%r15
  4050e0:	48 b8 09 00 00 00 02 	movabs $0x8000000200000009,%rax
  4050e7:	00 00 80 
  4050ea:	49 d1 ef             	shr    %r15
  4050ed:	49 f7 e7             	mul    %r15
  4050f0:	49 89 d7             	mov    %rdx,%r15
  4050f3:	49 c1 ef 1d          	shr    $0x1d,%r15
  4050f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4050fe:	00 00 
	    __uctype __tmp; // wraparound control
	    do
	      {
		const __uctype __uerngrange = __urngrange + 1;
		__tmp = (__uerngrange * operator()
			 (__urng, param_type(0, __urange / __uerngrange)));
  405100:	48 8d 54 24 20       	lea    0x20(%rsp),%rdx
  405105:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
  40510a:	4c 89 e6             	mov    %r12,%rsi
	typedef uniform_int_distribution<_IntType> distribution_type;

	explicit
	param_type(_IntType __a = 0,
		   _IntType __b = std::numeric_limits<_IntType>::max())
	: _M_a(__a), _M_b(__b)
  40510d:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
  405114:	00 00 
  405116:	4c 89 7c 24 28       	mov    %r15,0x28(%rsp)
  40511b:	e8 c0 fb ff ff       	callq  404ce0 <_ZNSt24uniform_int_distributionImEclISt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEEmRT_RKNS0_10param_typeE>
	    */
	    __uctype __tmp; // wraparound control
	    do
	      {
		const __uctype __uerngrange = __urngrange + 1;
		__tmp = (__uerngrange * operator()
  405120:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
  405124:	48 c1 e0 1f          	shl    $0x1f,%rax
  405128:	48 89 c6             	mov    %rax,%rsi
  40512b:	48 29 d6             	sub    %rdx,%rsi
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  40512e:	49 8b 14 24          	mov    (%r12),%rdx
  405132:	48 69 fa a7 41 00 00 	imul   $0x41a7,%rdx,%rdi
	  if (__m)
	    __res %= __m;
  405139:	48 89 f8             	mov    %rdi,%rax
  40513c:	49 f7 e5             	mul    %r13
  40513f:	48 89 f8             	mov    %rdi,%rax
  405142:	48 29 d0             	sub    %rdx,%rax
  405145:	48 d1 e8             	shr    %rax
  405148:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  40514c:	48 c1 e9 1e          	shr    $0x1e,%rcx
  405150:	48 89 c8             	mov    %rcx,%rax
  405153:	48 c1 e0 1f          	shl    $0x1f,%rax
  405157:	48 29 c8             	sub    %rcx,%rax
  40515a:	48 29 c7             	sub    %rax,%rdi
			 (__urng, param_type(0, __urange / __uerngrange)));
		__ret = __tmp + (__uctype(__urng()) - __urngmin);
  40515d:	48 8d 44 37 ff       	lea    -0x1(%rdi,%rsi,1),%rax
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  405162:	49 89 3c 24          	mov    %rdi,(%r12)
	      and
	
	      low in [0, urngrange].
	    */
	    __uctype __tmp; // wraparound control
	    do
  405166:	48 39 c6             	cmp    %rax,%rsi
  405169:	77 95                	ja     405100 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_+0x120>
  40516b:	49 39 c6             	cmp    %rax,%r14
  40516e:	72 90                	jb     405100 <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_+0x120>
  405170:	e9 2a ff ff ff       	jmpq   40509f <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_+0xbf>
  405175:	0f 1f 00             	nopl   (%rax)
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
	static _Tp
	__calc(_Tp __x)
	{
	  _Tp __res = __a * __x + __c;
  405178:	49 8b 04 24          	mov    (%r12),%rax
  40517c:	48 69 c8 a7 41 00 00 	imul   $0x41a7,%rax,%rcx
	  if (__m)
	    __res %= __m;
  405183:	48 89 c8             	mov    %rcx,%rax
  405186:	49 f7 e5             	mul    %r13
  405189:	48 89 c8             	mov    %rcx,%rax
  40518c:	48 29 d0             	sub    %rdx,%rax
  40518f:	48 d1 e8             	shr    %rax
  405192:	48 01 c2             	add    %rax,%rdx
  405195:	48 c1 ea 1e          	shr    $0x1e,%rdx
  405199:	48 89 d0             	mov    %rdx,%rax
  40519c:	48 c1 e0 1f          	shl    $0x1f,%rax
  4051a0:	48 29 d0             	sub    %rdx,%rax
  4051a3:	48 89 ca             	mov    %rcx,%rdx
  4051a6:	48 29 c2             	sub    %rax,%rdx
       * @brief Gets the next random number in the sequence.
       */
      result_type
      operator()()
      {
	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
  4051a9:	49 89 14 24          	mov    %rdx,(%r12)
		__ret = __tmp + (__uctype(__urng()) - __urngmin);
	      }
	    while (__ret > __urange || __ret < __tmp);
	  }
	else
	  __ret = __uctype(__urng()) - __urngmin;
  4051ad:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
  4051b1:	e9 e9 fe ff ff       	jmpq   40509f <_ZSt7shuffleIN9__gnu_cxx17__normal_iteratorIPxSt6vectorIxSaIxEEEERSt26linear_congruential_engineImLm16807ELm0ELm2147483647EEEvT_SA_OT0_+0xbf>
  4051b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4051bd:	00 00 00 

00000000004051c0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_>:

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
  4051c0:	41 57                	push   %r15
  4051c2:	41 56                	push   %r14
  4051c4:	41 55                	push   %r13
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
  4051c6:	41 bd 08 00 00 00    	mov    $0x8,%r13d
  4051cc:	41 54                	push   %r12
  4051ce:	55                   	push   %rbp
  4051cf:	48 89 fd             	mov    %rdi,%rbp
  4051d2:	53                   	push   %rbx
  4051d3:	48 83 ec 18          	sub    $0x18,%rsp

      // [23.2.4.2] capacity
      /**  Returns the number of elements in the %vector.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
  4051d7:	48 8b 47 08          	mov    0x8(%rdi),%rax
  4051db:	48 2b 07             	sub    (%rdi),%rax
  4051de:	48 c1 f8 03          	sar    $0x3,%rax
  4051e2:	48 85 c0             	test   %rax,%rax
  4051e5:	0f 85 f5 00 00 00    	jne    4052e0 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0x120>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  4051eb:	4c 89 ef             	mov    %r13,%rdi
  4051ee:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  4051f3:	e8 28 d4 ff ff       	callq  402620 <_Znwm@plt>
  4051f8:	48 8b 7d 08          	mov    0x8(%rbp),%rdi
  4051fc:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
  405200:	49 89 c4             	mov    %rax,%r12
  405203:	4c 8d 78 08          	lea    0x8(%rax),%r15
  405207:	48 89 f8             	mov    %rdi,%rax
  40520a:	48 29 c8             	sub    %rcx,%rax
	pointer __new_start(this->_M_allocate(__len));
	pointer __new_finish(__new_start);
	__try
	  {
	    _Alloc_traits::construct(this->_M_impl, __new_start + size(),
				     std::forward<_Args>(__args)...);
  40520d:	48 83 e0 f8          	and    $0xfffffffffffffff8,%rax

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  405211:	4c 01 e0             	add    %r12,%rax
  405214:	48 89 c2             	mov    %rax,%rdx
  405217:	0f 84 d8 00 00 00    	je     4052f5 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0x135>
	return get();
      }

      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
  40521d:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  405222:	48 8b 06             	mov    (%rsi),%rax
      // Modifiers.
      pointer
      release() noexcept
      {
	pointer __p = get();
	std::get<0>(_M_t) = pointer();
  405225:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
  40522c:	48 8b 7d 08          	mov    0x8(%rbp),%rdi
  405230:	48 8b 75 00          	mov    0x0(%rbp),%rsi
  405234:	48 89 02             	mov    %rax,(%rdx)
		      _ForwardIterator __result)
        {
	  _ForwardIterator __cur = __result;
	  __try
	    {
	      for (; __first != __last; ++__first, ++__cur)
  405237:	48 39 f7             	cmp    %rsi,%rdi
  40523a:	74 76                	je     4052b2 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0xf2>
  40523c:	48 89 f2             	mov    %rsi,%rdx
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
		      _ForwardIterator __result)
        {
	  _ForwardIterator __cur = __result;
  40523f:	4c 89 e1             	mov    %r12,%rcx
  405242:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
   */
#if __cplusplus >= 201103L
  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
  405248:	48 85 c9             	test   %rcx,%rcx
  40524b:	74 0d                	je     40525a <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0x9a>
	return get();
      }

      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
  40524d:	48 8b 02             	mov    (%rdx),%rax
      // Modifiers.
      pointer
      release() noexcept
      {
	pointer __p = get();
	std::get<0>(_M_t) = pointer();
  405250:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
  405257:	48 89 01             	mov    %rax,(%rcx)
      { return _M_current; }

      move_iterator&
      operator++()
      {
	++_M_current;
  40525a:	48 83 c2 08          	add    $0x8,%rdx
	  __try
	    {
	      for (; __first != __last; ++__first, ++__cur)
  40525e:	48 83 c1 08          	add    $0x8,%rcx
  405262:	48 39 fa             	cmp    %rdi,%rdx
  405265:	75 e1                	jne    405248 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0x88>
	      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
	    _M_deallocate(__new_start, __len);
	    __throw_exception_again;
	  }
	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator());
  405267:	4c 8b 75 08          	mov    0x8(%rbp),%r14
  40526b:	48 8b 5d 00          	mov    0x0(%rbp),%rbx
  40526f:	48 83 c6 08          	add    $0x8,%rsi
  405273:	48 29 f7             	sub    %rsi,%rdi
  405276:	48 c1 ef 03          	shr    $0x3,%rdi
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
	{
	  for (; __first != __last; ++__first)
  40527a:	49 39 de             	cmp    %rbx,%r14
	    __new_finish
	      = std::__uninitialized_move_if_noexcept_a
	      (this->_M_impl._M_start, this->_M_impl._M_finish,
	       __new_start, _M_get_Tp_allocator());

	    ++__new_finish;
  40527d:	4d 8d 7c fc 10       	lea    0x10(%r12,%rdi,8),%r15
  405282:	0f 84 90 00 00 00    	je     405318 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0x158>
  405288:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40528f:	00 

      // Destructor.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
  405290:	48 8b 3b             	mov    (%rbx),%rdi
  405293:	48 85 ff             	test   %rdi,%rdi
  405296:	74 06                	je     40529e <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0xde>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
  405298:	48 8b 07             	mov    (%rdi),%rax
  40529b:	ff 50 18             	callq  *0x18(%rax)
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
	  get_deleter()(__ptr);
	__ptr = pointer();
  40529e:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
  4052a5:	48 83 c3 08          	add    $0x8,%rbx
  4052a9:	49 39 de             	cmp    %rbx,%r14
  4052ac:	75 e2                	jne    405290 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0xd0>
  4052ae:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  4052b2:	48 85 ff             	test   %rdi,%rdi
  4052b5:	74 05                	je     4052bc <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0xfc>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  4052b7:	e8 94 d2 ff ff       	callq  402550 <_ZdlPv@plt>
	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator());
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
  4052bc:	4c 89 65 00          	mov    %r12,0x0(%rbp)
	this->_M_impl._M_finish = __new_finish;
	this->_M_impl._M_end_of_storage = __new_start + __len;
  4052c0:	4d 01 ec             	add    %r13,%r12
		      _M_get_Tp_allocator());
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
	this->_M_impl._M_finish = __new_finish;
  4052c3:	4c 89 7d 08          	mov    %r15,0x8(%rbp)
	this->_M_impl._M_end_of_storage = __new_start + __len;
  4052c7:	4c 89 65 10          	mov    %r12,0x10(%rbp)
      }
  4052cb:	48 83 c4 18          	add    $0x18,%rsp
  4052cf:	5b                   	pop    %rbx
  4052d0:	5d                   	pop    %rbp
  4052d1:	41 5c                	pop    %r12
  4052d3:	41 5d                	pop    %r13
  4052d5:	41 5e                	pop    %r14
  4052d7:	41 5f                	pop    %r15
  4052d9:	c3                   	retq   
  4052da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      _M_check_len(size_type __n, const char* __s) const
      {
	if (max_size() - size() < __n)
	  __throw_length_error(__N(__s));

	const size_type __len = size() + std::max(size(), __n);
  4052e0:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
	return (__len < size() || __len > max_size()) ? max_size() : __len;
  4052e4:	48 39 d0             	cmp    %rdx,%rax
  4052e7:	76 14                	jbe    4052fd <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0x13d>
  4052e9:	49 c7 c5 f8 ff ff ff 	mov    $0xfffffffffffffff8,%r13
  4052f0:	e9 f6 fe ff ff       	jmpq   4051eb <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0x2b>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  4052f5:	48 89 ce             	mov    %rcx,%rsi
  4052f8:	e9 3a ff ff ff       	jmpq   405237 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0x77>
  4052fd:	48 b9 ff ff ff ff ff 	movabs $0x1fffffffffffffff,%rcx
  405304:	ff ff 1f 
  405307:	48 39 ca             	cmp    %rcx,%rdx
  40530a:	77 dd                	ja     4052e9 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0x129>
  40530c:	49 89 c5             	mov    %rax,%r13
  40530f:	49 c1 e5 04          	shl    $0x4,%r13
  405313:	e9 d3 fe ff ff       	jmpq   4051eb <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0x2b>
  405318:	4c 89 f7             	mov    %r14,%rdi
  40531b:	eb 95                	jmp    4052b2 <_ZNSt6vectorISt10unique_ptrI6entitySt14default_deleteIS1_EESaIS4_EE19_M_emplace_back_auxIIS4_EEEvDpOT_+0xf2>
  40531d:	0f 1f 00             	nopl   (%rax)

0000000000405320 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EE19_M_emplace_back_auxIINS1_IdS2_ILl1ELl1EEEEEEEvDpOT_>:

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
  405320:	41 56                	push   %r14
  405322:	49 89 f6             	mov    %rsi,%r14
  405325:	41 55                	push   %r13
  405327:	41 54                	push   %r12
  405329:	41 bc 08 00 00 00    	mov    $0x8,%r12d
  40532f:	55                   	push   %rbp
  405330:	53                   	push   %rbx

      // [23.2.4.2] capacity
      /**  Returns the number of elements in the %vector.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
  405331:	48 8b 57 08          	mov    0x8(%rdi),%rdx
  405335:	48 89 fb             	mov    %rdi,%rbx
  405338:	48 2b 17             	sub    (%rdi),%rdx
  40533b:	48 c1 fa 03          	sar    $0x3,%rdx
  40533f:	48 85 d2             	test   %rdx,%rdx
  405342:	75 7c                	jne    4053c0 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EE19_M_emplace_back_auxIINS1_IdS2_ILl1ELl1EEEEEEEvDpOT_+0xa0>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  405344:	4c 89 e7             	mov    %r12,%rdi
  405347:	e8 d4 d2 ff ff       	callq  402620 <_Znwm@plt>
  40534c:	48 8b 33             	mov    (%rbx),%rsi
  40534f:	48 89 c5             	mov    %rax,%rbp
  405352:	48 8b 43 08          	mov    0x8(%rbx),%rax

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
  405356:	49 89 ed             	mov    %rbp,%r13
  405359:	48 29 f0             	sub    %rsi,%rax
  40535c:	48 c1 f8 03          	sar    $0x3,%rax
	pointer __new_start(this->_M_allocate(__len));
	pointer __new_finish(__new_start);
	__try
	  {
	    _Alloc_traits::construct(this->_M_impl, __new_start + size(),
				     std::forward<_Args>(__args)...);
  405360:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  405367:	00 
  405368:	49 01 d5             	add    %rdx,%r13
  40536b:	74 13                	je     405380 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EE19_M_emplace_back_auxIINS1_IdS2_ILl1ELl1EEEEEEEvDpOT_+0x60>
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(
	      static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));
  40536d:	f2 0f 10 05 43 05 00 	movsd  0x543(%rip),%xmm0        # 4058b8 <_ZN14entity_hermite4typeE+0xa8>
  405374:	00 
  405375:	f2 41 0f 59 06       	mulsd  (%r14),%xmm0
	template<typename _Rep2, typename _Period2, typename = typename
	       enable_if<treat_as_floating_point<rep>::value
			 || (ratio_divide<_Period2, period>::den == 1
			     && !treat_as_floating_point<_Rep2>::value)>::type>
	  constexpr duration(const duration<_Rep2, _Period2>& __d)
	  : __r(duration_cast<duration>(__d).count()) { }
  40537a:	f2 41 0f 11 45 00    	movsd  %xmm0,0x0(%r13)
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
	  const ptrdiff_t _Num = __last - __first;
	  if (_Num)
  405380:	48 85 c0             	test   %rax,%rax
  405383:	48 89 f7             	mov    %rsi,%rdi
  405386:	74 0b                	je     405393 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EE19_M_emplace_back_auxIINS1_IdS2_ILl1ELl1EEEEEEEvDpOT_+0x73>
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
  405388:	48 89 ef             	mov    %rbp,%rdi
  40538b:	e8 50 d2 ff ff       	callq  4025e0 <memmove@plt>
  405390:	48 8b 3b             	mov    (%rbx),%rdi
	    __new_finish
	      = std::__uninitialized_move_if_noexcept_a
	      (this->_M_impl._M_start, this->_M_impl._M_finish,
	       __new_start, _M_get_Tp_allocator());

	    ++__new_finish;
  405393:	49 83 c5 08          	add    $0x8,%r13
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	if (__p)
  405397:	48 85 ff             	test   %rdi,%rdi
  40539a:	74 05                	je     4053a1 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EE19_M_emplace_back_auxIINS1_IdS2_ILl1ELl1EEEEEEEvDpOT_+0x81>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  40539c:	e8 af d1 ff ff       	callq  402550 <_ZdlPv@plt>
	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator());
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
  4053a1:	48 89 2b             	mov    %rbp,(%rbx)
	this->_M_impl._M_finish = __new_finish;
	this->_M_impl._M_end_of_storage = __new_start + __len;
  4053a4:	4c 01 e5             	add    %r12,%rbp
		      _M_get_Tp_allocator());
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
	this->_M_impl._M_finish = __new_finish;
  4053a7:	4c 89 6b 08          	mov    %r13,0x8(%rbx)
	this->_M_impl._M_end_of_storage = __new_start + __len;
  4053ab:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
      }
  4053af:	5b                   	pop    %rbx
  4053b0:	5d                   	pop    %rbp
  4053b1:	41 5c                	pop    %r12
  4053b3:	41 5d                	pop    %r13
  4053b5:	41 5e                	pop    %r14
  4053b7:	c3                   	retq   
  4053b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4053bf:	00 
      _M_check_len(size_type __n, const char* __s) const
      {
	if (max_size() - size() < __n)
	  __throw_length_error(__N(__s));

	const size_type __len = size() + std::max(size(), __n);
  4053c0:	48 8d 04 12          	lea    (%rdx,%rdx,1),%rax
	return (__len < size() || __len > max_size()) ? max_size() : __len;
  4053c4:	48 39 c2             	cmp    %rax,%rdx
  4053c7:	76 0c                	jbe    4053d5 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EE19_M_emplace_back_auxIINS1_IdS2_ILl1ELl1EEEEEEEvDpOT_+0xb5>
  4053c9:	49 c7 c4 f8 ff ff ff 	mov    $0xfffffffffffffff8,%r12
  4053d0:	e9 6f ff ff ff       	jmpq   405344 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EE19_M_emplace_back_auxIINS1_IdS2_ILl1ELl1EEEEEEEvDpOT_+0x24>
  4053d5:	48 b9 ff ff ff ff ff 	movabs $0x1fffffffffffffff,%rcx
  4053dc:	ff ff 1f 
  4053df:	48 c1 e2 04          	shl    $0x4,%rdx
  4053e3:	49 c7 c4 f8 ff ff ff 	mov    $0xfffffffffffffff8,%r12
  4053ea:	48 39 c8             	cmp    %rcx,%rax
  4053ed:	4c 0f 46 e2          	cmovbe %rdx,%r12
  4053f1:	e9 4e ff ff ff       	jmpq   405344 <_ZNSt6vectorINSt6chrono8durationIdSt5ratioILl1ELl1000EEEESaIS4_EE19_M_emplace_back_auxIINS1_IdS2_ILl1ELl1EEEEEEEvDpOT_+0x24>
  4053f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4053fd:	00 00 00 

0000000000405400 <__libc_csu_init>:
  405400:	41 57                	push   %r15
  405402:	41 89 ff             	mov    %edi,%r15d
  405405:	41 56                	push   %r14
  405407:	49 89 f6             	mov    %rsi,%r14
  40540a:	41 55                	push   %r13
  40540c:	49 89 d5             	mov    %rdx,%r13
  40540f:	41 54                	push   %r12
  405411:	4c 8d 25 c0 19 20 00 	lea    0x2019c0(%rip),%r12        # 606dd8 <__frame_dummy_init_array_entry>
  405418:	55                   	push   %rbp
  405419:	48 8d 2d d8 19 20 00 	lea    0x2019d8(%rip),%rbp        # 606df8 <__init_array_end>
  405420:	53                   	push   %rbx
  405421:	4c 29 e5             	sub    %r12,%rbp
  405424:	31 db                	xor    %ebx,%ebx
  405426:	48 c1 fd 03          	sar    $0x3,%rbp
  40542a:	48 83 ec 08          	sub    $0x8,%rsp
  40542e:	e8 cd d0 ff ff       	callq  402500 <_init>
  405433:	48 85 ed             	test   %rbp,%rbp
  405436:	74 1e                	je     405456 <__libc_csu_init+0x56>
  405438:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40543f:	00 
  405440:	4c 89 ea             	mov    %r13,%rdx
  405443:	4c 89 f6             	mov    %r14,%rsi
  405446:	44 89 ff             	mov    %r15d,%edi
  405449:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
  40544d:	48 83 c3 01          	add    $0x1,%rbx
  405451:	48 39 eb             	cmp    %rbp,%rbx
  405454:	75 ea                	jne    405440 <__libc_csu_init+0x40>
  405456:	48 83 c4 08          	add    $0x8,%rsp
  40545a:	5b                   	pop    %rbx
  40545b:	5d                   	pop    %rbp
  40545c:	41 5c                	pop    %r12
  40545e:	41 5d                	pop    %r13
  405460:	41 5e                	pop    %r14
  405462:	41 5f                	pop    %r15
  405464:	c3                   	retq   
  405465:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  40546c:	00 00 00 00 

0000000000405470 <__libc_csu_fini>:
  405470:	f3 c3                	repz retq 

Disassembly of section .fini:

0000000000405474 <_fini>:
  405474:	48 83 ec 08          	sub    $0x8,%rsp
  405478:	48 83 c4 08          	add    $0x8,%rsp
  40547c:	c3                   	retq   
